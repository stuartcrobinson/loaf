=== START FILE: /Users/stuart/repos/loaf/unified-design.yaml ===
# AI Coder Tools Schema - Unified Design

# Loaf executes filesystem and runtime commands embedded in LLM output using NESL syntax. It provides deterministic filesystem access and shell command execution for LLM coding agents.

# NESL syntax example:

NESL_synatx_example: |
  ```sh nesl
  #!nesl [@three-char-SHA-256: k7m]
  action = "file_write"
  path = "/tmp/\"hello\".txt"
  content = <<'EOT_k7m'
  Hello world!
  how are you?
  EOT_k7m
  #!end_k7m
  ```


tools:
  # File Operations
  file_write:
    type: write
    executor: fs-ops
    description: Create new file while creating any necessary parent dirs. overwrites if already exists
    accessibility: [llm]
    output_display: never
    primary_param: path
    parameters:
      path: {type: string, required: true, format: absolute_path}
      content: {type: string, required: true}
    returns: {success: boolean, error?: string}
    
    
  file_replace_text:
    type: write
    executor: fs-ops
    description: Replace first and only instance of substring in file. must exist only once
    accessibility: [llm]
    output_display: never
    primary_param: path
    parameters:
      path: {type: string, required: true, format: absolute_path}
      old_text: {type: string, required: true}
      new_text: {type: string, required: true}
    returns: {success: boolean, replacements_made?: integer, error?: string}
    
  file_replace_text_range:
    type: write
    executor: fs-ops
    description: Replace first and only instance of text range in file. must exist only once
    accessibility: [llm]
    output_display: never
    primary_param: path
    parameters:
      path: {type: string, required: true, format: absolute_path}
      old_text_beginning: {type: string, required: true}
      old_text_end: {type: string, required: true}
      new_text: {type: string, required: true}
    returns: {success: boolean, replacements_made?: integer, error?: string}
    
  file_replace_all_text:
    type: write
    executor: fs-ops
    description: Replace each matching substring in file.  Number of matches (count) should usually be known and declared ahead of time.
    accessibility: [llm]
    output_display: never
    primary_param: path
    parameters:
      path: {type: string, required: true, format: absolute_path}
      old_text: {type: string, required: true}
      new_text: {type: string, required: true}
      count: {type: integer, required: false}
    returns: {success: boolean, replacements_made?: integer, error?: string}
    

  #tentative!  under consideration
  files_replace_all_text:
    type: write
    executor: fs-ops
    description: Replace all occurrences of substring in multiple files. Processes each file independently
    accessibility: [llm]
    parameters:
      paths: {type: string, format: multiline_absolute_paths}
      old_text: {type: string, required: true}
      new_text: {type: string, required: true}
    returns: {
      success: boolean,
      results: {
        type: array,
        items: {
          path: string,
          replacements_made: integer,
          error?: string
        }
      },
      error?: string  # for complete failure
    }



  #tentative!  under consideration.  dont implement yet
  # actually.... for "in parents" stuff lets just use our exisitng actions, but allow "parent" stuff to be added to the path, like ina  syntax we created earlier but forgot about
  # like:
  # path/to/file.md@@## Section 2@@### part 3
  # path/to/code.rs@@MyModuleOrClass@@myFunction
  files_replace_text_in_parents:
    type: write
    executor: fs-ops
    description: Replace all occurrences of substring in a given node of a parsed file that supports grouping, like markdown, code (ast), etc 
    accessibility: [llm]
    parameters:
      path: {type: string, required: true}
      parents: {type: string, required: true, format: multiline_absolute_paths} # need to better define how parents are defined
      old_text: {type: string, required: true}
      new_text: {type: string, required: true}


  file_append:
    type: write
    executor: fs-ops
    description: Append to file
    accessibility: [llm]
    parameters:
      path: {type: string, required: true, format: absolute_path}
      content: {type: string, required: true}
    returns: {success: boolean, error?: string}
    
  file_delete:
    type: write
    executor: fs-ops
    description: Delete file
    accessibility: [llm]
    output_display: never
    primary_param: path
    parameters:
      path: {type: string, required: true, format: absolute_path}
    returns: {success: boolean, error?: string}
    
  file_move:
    type: write
    executor: fs-ops
    description: Move/rename file
    accessibility: [llm]
    output_display: never
    primary_param: old_path
    parameters:
      old_path: {type: string, required: true, format: absolute_path}
      new_path: {type: string, required: true, format: absolute_path}
    returns: {success: boolean, error?: string}
    


  file_read:
    type: read
    executor: fs-ops
    description: Read single file content
    accessibility: [llm]
    output_display: always
    primary_param: path
    parameters:
      path: {type: string, required: true, format: absolute_path}
    returns: {success: boolean, content?: string, error?: string}

  file_read_numbered:
    type: read
    executor: fs-ops
    description: Read file content with line numbers for specified line range
    accessibility: [llm]
    output_display: always
    primary_param: path
    parameters:
      path: {type: string, required: true, format: absolute_path}
      lines: {type: string, required: false, description: "Line range: single '4' or range '23-43'. If omitted, reads all lines."}
      delimiter: {type: string, required: false, default: ": ", description: "Delimiter between line number and content"}
    returns: {success: boolean, content?: string, error?: string}

  file_replace_lines:
    type: write
    executor: fs-ops
    description: Replace specified line range in file with new content
    accessibility: [llm]
    output_display: never
    primary_param: path
    parameters:
      path: {type: string, required: true, format: absolute_path}
      lines: {type: string, required: true, description: "Line range: single '4' or range '23-43'"}
      new_content: {type: string, required: true, description: "Content to replace the line range with"}
    returns: {success: boolean, lines_replaced?: integer, error?: string}


  files_read:
    type: read
    executor: fs-ops
    description: Read and concatenate contents of multiple files into a single string, with clear file delimiters
    accessibility: [llm]
    output_display: always
    primary_param: paths
    parameters:
      paths: {
        type: string, 
        required: true, 
        format: "multiline_absolute_paths",
        description: "One absolute file path per line. Empty lines are ignored."
      }
    returns: {
      success: boolean, 
      data?: {                          # i guess this is formatted wrong... 
        paths: array, content: array
        },
      error?: string
    }  
    example: |
      paths: |
        /home/user/projects/src/main.py
        /home/user/projects/src/utils.py
        /home/user/projects/README.md
    
  # Directory Operations
  dir_create:
    type: write
    executor: fs-ops
    description: Create directory
    accessibility: [llm]
    output_display: never
    primary_param: path
    parameters:
      path: {type: string, required: true, format: absolute_path}
    returns: {success: boolean, error?: string}
    
  dir_delete:
    type: write
    executor: fs-ops
    description: Delete directory
    accessibility: [llm]
    output_display: never
    primary_param: path
    parameters:
      path: {type: string, required: true, format: absolute_path}
    returns: {success: boolean, error?: string}
    
  # Read Operations
  ls:
    type: read
    executor: fs-ops
    description: List directory contents
    accessibility: [llm]
    output_display: always
    primary_param: path
    parameters:
      path: {type: string, required: true, format: absolute_path}
    returns: 
      success: boolean
      data:
        type: array
        items:
          name: string
          type: string  # file|directory
          size: integer
          modified: timestamp
      error: string
    
  grep:
    type: read
    description: Search pattern in files
    accessibility: [llm]
    output_display: always
    primary_param: pattern
    parameters:
      pattern: {type: string, required: true}
      path: {type: string, required: true, format: absolute_path}
      include: {type: string, required: false}
    returns: 
      success: boolean
      data:
        type: array
        items:
          file: string
          line_number: integer
          line: string
      error: string
    
  glob:
    type: read
    description: Find files matching pattern
    accessibility: [llm]
    output_display: always
    primary_param: pattern
    parameters:
      pattern: {type: string, required: true}
      base_path: {type: string, required: true, format: absolute_path}
    returns: 
      success: boolean
      data:
        type: array
        items: string
      error: string
    
  # Execution
  exec:
    type: dynamic
    description: Execute code
    accessibility: [llm]
    output_display: conditional  # Check return_output parameter
    primary_param: lang
    parameters:
      code: {type: string, required: true}
      lang: {type: enum, values: [python, javascript, bash], required: true}
      version: {type: string, required: false}
      cwd: {type: string, required: false, format: absolute_path}
      return_output: {type: boolean, required: false, default: true}
    returns: {success: boolean, stdout?: string, stderr?: string, exit_code?: integer, error?: string}

  # Context Operations -- for much later.  dont do this until loaf has been integrated into bigfoot, the ai llm coder
  context_add:
    type: meta
    description: Add item to working context (persistent)
    accessibility: [llm, user]
    parameters:
      path: {type: string, required: true, format: absolute_path}
    returns: {success: boolean, error?: string}
      
  context_remove:
    type: meta
    description: Remove item from working context
    accessibility: [llm, user]
    parameters:
      path: {type: string, required: true, format: absolute_path}
    returns: {success: boolean, error?: string}
      
  context_list:
    type: meta
    description: List items in working context
    accessibility: [llm, user]
    parameters: {}
    returns: 
      success: boolean
      data:
        type: array
        items:
          path: string
          size: integer
      error: string
    
  context_prune:
    type: meta
    description: Remove unused items from working context
    accessibility: [llm, user]
    parameters: {}
    returns: {success: boolean, removed?: array of strings, error?: string}
    
  context_clear:
    type: meta
    description: Clear all working context items
    accessibility: [llm, user]
    parameters: {}
    returns: {success: boolean, error?: string}
    
  # Git Operations
  git_squash:
    type: git
    description: Squash commits
    slash_command: true
    parameters:
      mode: {type: enum, values: [auto_ai, ai_messages, hours, days, contiguous_only=true, msg_contains], required: true}
      message: {type: string, required: false}
      hours: {type: integer, required: false, when: "mode=hours"}
      days: {type: integer, required: false, when: "mode=days"}
      msg_target: {type: string, required: false, when: "mode=msg_contains"}
    returns: {success: boolean, error?: string}
      
  undo:
    type: git
    description: Undo last AI changes
    accessibility: [user]
    constraints: ["No changes since last AI operation"]
    parameters: {}
    returns: {success: boolean, error?: string}
    
  git_step_back:
    type: git
    description: Move to previous commit
    accessibility: [user]
    behavior: Stashes untracked changes
    parameters: {}
    returns: {success: boolean, stashed_files?: array of strings, error?: string}
    
  git_step_forward:
    type: git
    description: Move to next commit
    accessibility: [user]
    behavior: Attempts to pop stashed changes
    parameters: {}
    returns: {success: boolean, conflicts?: array of strings, error?: string}

# Transaction Management
transaction_model:
  strategy: operation_group
  conflict_detection:
    methods:
      - mtime comparison (fast but unreliable)
      - checksum comparison (slower but accurate)
      - git status check (catches git-tracked changes)
    timing:
      - Check immediately before operation group
      - Check after each write operation
      - Final check before commit
  implementation:
    - Begin: git commit current state
    - Execute: track all operations
    - Validate: check for external modifications
    - Success: git commit with summary
    - Failure: git reset --hard to start
  atomicity: none  # Git operations are NOT atomic at filesystem level
  
# Security Model
security:
  path_validation:
    type: allowlist
    allowed_roots:
      - /home/user/projects
      - /tmp/ai-coder
    blacklist_patterns:
      - .*\.ssh.*
      - .*\.git/config
      - /etc/.*
      - /sys/.*
      - /proc/.*
  canonicalization: required  # Resolve ../ and symlinks before checking
  
# System Configuration
config:
  encoding: utf-8
  line_endings: preserve  # Don't normalize
  max_file_size: 10485760  # 10MB
  git_auto_push: false  # Require explicit push
  commit_message_format: "AI: {operation_summary}"

TODO: |   
  Transaction Safety: The git-based transaction model has race conditions:

    Gap between "git commit" and first operation
    Non-atomic filesystem ops vs git state


# more TODO 


  #tentative!  under consideration.  dont implement yet
  # actually.... for "in parents" stuff lets just use our exisitng tools, but allow "parent" stuff to be added to the path, like ina  syntax we created earlier but forgot about
  # like:
  # path/to/file.md@@## Section 2@@### part 3
  # path/to/code.rs@@MyModuleOrClass@@myFunction

  # and add a wayt o get file numbers per read.  like an attribute to add to file_read to get the text with line numbers. and then a file_lines_replace that takes in a line range and replacement_text params. or maybe even each as an array.  maybe we should just change nesl-js so its not an error to have repeated values.  cos right now its like impossible to make a lot of small changes to a big code file.  but if we new the line number per each... that would make it easy for LLM... 
=== END FILE: /Users/stuart/repos/loaf/unified-design.yaml ===

=== START FILE: /Users/stuart/repos/loaf/proj/comp/listener/src/unified-design-loader.ts ===
import { readFile } from 'fs/promises';
import { parse as parseYaml } from 'js-yaml';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';

//TODO ! at some point, lets make a generic "loader" cos tehres other files i want to load.  like to use a default-loaf.yaml instead of storing it as a string in ts.  and... maybe tooling for generating the llm_instructions doc (per allowed tools) maybe... 

interface ToolDefinition {
  output_display?: 'always' | 'never' | 'conditional';
  parameters?: Record<string, any>;
}

interface UnifiedDesign {
  tools: Record<string, ToolDefinition>;
}

let cachedDesign: UnifiedDesign | null = null;

/**
 * Load and cache the unified design configuration.
 * Returns the parsed unified design object.
 */
export async function loadUnifiedDesign(): Promise<UnifiedDesign> {
  if (cachedDesign) {
    return cachedDesign;
  }

  const __dirname = dirname(fileURLToPath(import.meta.url));
  const designPath = join(__dirname, '../../../doc/unified-design.yaml');
  const content = await readFile(designPath, 'utf-8');
  cachedDesign = parseYaml(content) as UnifiedDesign;
  
  return cachedDesign;
}

/**
 * Check if output should be displayed for a given action.
 * Returns true if output should be included in OUTPUTS section.
 */
export async function shouldDisplayOutput(
  action: string, 
  params: Record<string, any> = {}
): Promise<boolean> {
  const design = await loadUnifiedDesign();
  const tool = design.tools[action];
  
  if (!tool) {
    // Unknown tool - default to showing output
    return true;
  }
  
  const displayRule = tool.output_display || 'always';
  
  switch (displayRule) {
    case 'always':
      return true;
    case 'never':
      return false;
    case 'conditional':
      // For exec, check return_output parameter
      if (action === 'exec') {
        return params.return_output !== false;
      }
      // Default for other conditional actions
      return true;
    default:
      return true;
  }
}
=== END FILE: /Users/stuart/repos/loaf/proj/comp/listener/src/unified-design-loader.ts ===

=== START FILE: /Users/stuart/repos/loaf/proj/comp/orch/src/index.ts ===
import type { LoafAction, ParseResult, ParseError } from '../../nesl-action-parser/src/index.js';
import { parseNeslResponse } from '../../nesl-action-parser/src/index.js';
import type { FileOpResult } from '../../fs-ops/src/index.js';
import { FsOpsExecutor } from '../../fs-ops/src/index.js';
import type { HooksConfig, HookContext, HookResult } from '../../hooks/src/index.js';
import { HooksManager } from '../../hooks/src/index.js';
import { FsGuard } from '../../fs-guard/src/index.js';
import { ExecExecutor } from '../../exec/src/index.js';
import { load as loadYaml } from 'js-yaml';
import { readFile } from 'fs/promises';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';
import { loadConfig } from '../../config/src/index.js';
import type { LoafConfig } from '../../config/src/index.js';
import { updateInstructions } from '../../instruct-gen/src/index.js';
import { updateInstructions } from '../../instruct-gen/src/index.js';

export interface ExecutionResult {
  success: boolean;
  totalBlocks: number;
  executedActions: number;
  results: ActionResult[];
  parseErrors: ParseError[];
  fatalError?: string;
  hookErrors?: {
    before?: string[];
    after?: string[];
  };
  debug?: {
    parseDebug?: any;
  };
}

export interface ActionResult {
  seq: number;
  blockId: string;
  action: string;
  params: Record<string, any>;
  success: boolean;
  error?: string;
  data?: any;
}

export interface LoafOptions {
  repoPath?: string;
  gitCommit?: boolean;
  hooks?: HooksConfig;
  enableHooks?: boolean;
}

export class Loaf {
  private constructor(
    private config: LoafConfig,
    private executors: Map<string, (action: LoafAction) => Promise<FileOpResult>>,
    private hooksManager: HooksManager | undefined,
    private repoPath: string
  ) { }

  static async create(options: LoafOptions = {}): Promise<Loaf> {
    const repoPath = options.repoPath || process.cwd();

    // Load configuration
    const config = await loadConfig(repoPath);

    // Update instructions file if needed
    await updateInstructions(repoPath, config['allowed-actions']);

    // Initialize executors
    const executors = await Loaf.initializeExecutors(config, repoPath);

    // Initialize hooks if enabled
    let hooksManager: HooksManager | undefined;
    if (options.enableHooks !== false) {
      if (options.hooks) {
        // Use provided hooks configuration
        hooksManager = new HooksManager(options.hooks, undefined, repoPath);
      } else if (config.hooks) {
        // Use hooks from loaded config
        hooksManager = new HooksManager(config.hooks, config.vars, repoPath);
      }
    }

    return new Loaf(config, executors, hooksManager, repoPath);
  }

  /**
   * Parse and execute all NESL blocks in LLM output
   * Executes all valid actions sequentially, collecting both successes and failures
   */
  async execute(llmOutput: string): Promise<ExecutionResult> {
    const hookErrors: ExecutionResult['hookErrors'] = {};

    try {

      // Run before hooks
      if (this.hooksManager) {
        try {
          const beforeResult = await this.hooksManager.runBefore();
          if (!beforeResult.success) {
            // Before hook failure is fatal
            return {
              success: false,
              totalBlocks: 0,
              executedActions: 0,
              results: [],
              parseErrors: [],
              hookErrors: {
                before: beforeResult.errors?.map(e => `${e.command}: ${e.error}`) || ['Unknown before hook error']
              },
              fatalError: 'Before hooks failed - aborting execution'
            };
          }
        } catch (error) {
          return {
            success: false,
            totalBlocks: 0,
            executedActions: 0,
            results: [],
            parseErrors: [],
            fatalError: `Before hooks threw unexpected error: ${error instanceof Error ? error.message : String(error)}`
          };
        }
      }

      // Parse NESL blocks
      const parseResult = await parseNeslResponse(llmOutput);

      // Debug info captured in parseResult.debug

      // Execute each valid action sequentially
      const results: ActionResult[] = [];
      let seq = 1;

      for (const action of parseResult.actions) {
        const result = await this.executeAction(action, seq++);
        results.push(result);
      }

      // Calculate execution success (before considering after hooks)
      const allActionsSucceeded = results.every(r => r.success);
      const noParseErrors = parseResult.errors.length === 0;
      const executionSuccess = allActionsSucceeded && noParseErrors;

      // Run after hooks with context
      if (this.hooksManager) {
        try {
          // Build rich context for hooks
          const modifiedFiles = new Set<string>();
          const operations: string[] = [];
          const errors: string[] = [];

          for (const result of results) {
            if (result.action.startsWith('file_') && result.params.path) {
              modifiedFiles.add(result.params.path);
            }

            operations.push(`${result.action}${result.success ? '' : ' (failed)'}`);

            if (!result.success && result.error) {
              errors.push(`${result.action}: ${result.error}`);
            }
          }

          const afterContext: HookContext = {
            success: executionSuccess,
            executedActions: results.length,
            totalBlocks: parseResult.summary.totalBlocks,
            modifiedFiles: Array.from(modifiedFiles).join(','),
            operations: operations.join(','),
            errors: errors.join('; '),
            errorCount: errors.length
          };

          const afterResult = await this.hooksManager.runAfter(afterContext);
          if (!afterResult.success) {
            // After hook failure affects overall success
            hookErrors.after = afterResult.errors?.map(e => `${e.command}: ${e.error}`) || ['Unknown after hook error'];
          }
        } catch (error) {
          // After hook unexpected errors also affect success
          hookErrors.after = [`After hooks threw unexpected error: ${error instanceof Error ? error.message : String(error)}`];
        }
      }

      return {
        success: executionSuccess && !hookErrors.after, // After hook errors affect overall success
        totalBlocks: parseResult.summary.totalBlocks,
        executedActions: results.length,
        results,
        parseErrors: parseResult.errors,
        ...(Object.keys(hookErrors).length > 0 && { hookErrors }),
        debug: {
          parseDebug: parseResult.debug
        }
      };

    } catch (error) {
      // Only truly unexpected errors should reach here
      return {
        success: false,
        totalBlocks: 0,
        executedActions: 0,
        results: [],
        parseErrors: [],
        fatalError: `Unexpected error in execute: ${error instanceof Error ? error.message : String(error)}`
      };
    }
  }



  /**
   * Initialize action executors with configuration
   */
  private static async initializeExecutors(config: LoafConfig, repoPath: string): Promise<Map<string, (action: LoafAction) => Promise<FileOpResult>>> {

    // Create fs-guard with config or empty object
    const fsGuardConfig = config['fs-guard'] || {};
    const fsGuard = new FsGuard(fsGuardConfig, repoPath);

    // Create executors
    const fsOps = new FsOpsExecutor(fsGuard);
    const exec = new ExecExecutor();

    // Load unified-design.yaml for routing
    const __filename = fileURLToPath(import.meta.url);
    const __dirname = dirname(__filename);
    const yamlPath = join(__dirname, '../../../../unified-design.yaml');
    const yamlContent = await readFile(yamlPath, 'utf8');
    const design = loadYaml(yamlContent) as any;

    // Build routing table from YAML
    const executors = new Map<string, (action: LoafAction) => Promise<FileOpResult>>();
    const validActions = new Set<string>();

    for (const [actionName, actionDef] of Object.entries(design.tools)) {
      validActions.add(actionName);
      const executorName = (actionDef as any).executor || Loaf.inferExecutor(actionName, actionDef);

      switch (executorName) {
        case 'fs-ops':
          executors.set(actionName, (action) => fsOps.execute(action));
          break;
        case 'exec':
          executors.set(actionName, (action) => exec.execute(action));
          break;
        // Skip unimplemented executors
        case 'context':
        case 'git':
          break;
        default:
          console.warn(`Unknown executor: ${executorName} for action: ${actionName}`);
      }
    }

    // Validate allowed-actions against actual available tools
    for (const tool of config['allowed-actions']) {
      if (!validActions.has(tool)) {
        throw new Error(`Invalid action in allowed-actions: '${tool}'. Valid actions: ${Array.from(validActions).join(', ')}`);
      }
    }

    return executors;
  }

  /**
   * Infer executor from action name/type when not explicitly defined
   * Temporary fallback until all YAML entries have executor field
   */
  private static inferExecutor(actionName: string, actionDef: any): string | null {
    // File/dir operations go to fs-ops
    if (actionName.startsWith('file_') || actionName.startsWith('files_') ||
      actionName.startsWith('dir_') || ['ls', 'grep', 'glob'].includes(actionName)) {
      return 'fs-ops';
    }

    // Exec operations
    if (actionName === 'exec') {
      return 'exec';
    }

    // Context operations (future)
    if (actionName.startsWith('context_')) {
      return 'context';
    }

    // Git operations (future)
    if (actionName.startsWith('git_') || actionName === 'undo') {
      return 'git';
    }

    return null;
  }

  /**
   * Execute a single action and format the result
   * Never throws - all errors returned in ActionResult
   */
  private async executeAction(action: LoafAction, seq: number): Promise<ActionResult> {
    if (!this.config['allowed-actions'].includes(action.action)) {
      return {
        seq,
        blockId: action.metadata.blockId,
        action: action.action,
        params: action.parameters,
        success: false,
        error: `Action '${action.action}' is not in allowed-actions list`
      };
    }

    const executor = this.executors.get(action.action);

    if (!executor) {
      return {
        seq,
        blockId: action.metadata.blockId,
        action: action.action,
        params: action.parameters,
        success: false,
        error: `Unknown action: ${action.action}`
      };
    }

    try {
      // Add default cwd for exec actions if not specified
      const enhancedAction = action.action === 'exec' && !action.parameters.cwd
        ? { ...action, parameters: { ...action.parameters, cwd: this.repoPath } }
        : action;

      const result = await executor(enhancedAction);

      return {
        seq,
        blockId: action.metadata.blockId,
        action: action.action,
        params: action.parameters,
        success: result.success,
        ...(result.error && { error: result.error }),
        ...(result.data !== undefined && { data: result.data }),
        // Include exec-specific fields at top level
        ...(action.action === 'exec' && {
          data: {
            stdout: result.stdout,
            stderr: result.stderr,
            exit_code: result.exit_code
          }
        })
      };

    } catch (error) {
      // Executors should never throw, but handle just in case
      return {
        seq,
        blockId: action.metadata.blockId,
        action: action.action,
        params: action.parameters,
        success: false,
        error: `Unexpected executor error: ${error instanceof Error ? error.message : String(error)}`
      };
    }
  }
}
=== END FILE: /Users/stuart/repos/loaf/proj/comp/orch/src/index.ts ===

=== START FILE: /Users/stuart/repos/loaf/proj/comp/fs-guard/src/FsGuard.ts ===
import { realpath } from 'fs/promises';
import { minimatch } from 'minimatch';
import { dirname, resolve, isAbsolute } from 'path';
import type { LoafAction } from '../../nesl-action-parser/src/index.js';
import type { FsGuardConfig } from '../../orch/src/types.js';
import type { GuardCheckResult, PathPermission } from './types.js';

export class FsGuard {
  private allowedPatterns: string[];
  private deniedPatterns: string[];
  private followSymlinks: boolean;

  // Permission mapping for each action
  private static readonly ACTION_PERMISSIONS: Record<string, PathPermission[]> = {
    file_read: [{ type: 'read', path: 'path', paramName: 'path' }],
    file_write: [{ type: 'write', path: 'path', paramName: 'path' }],
    file_create: [{ type: 'write', path: 'path', paramName: 'path' }],
    file_delete: [{ type: 'write', path: 'path', paramName: 'path' }],
    file_replace_text: [
      { type: 'read', path: 'path', paramName: 'path' },
      { type: 'write', path: 'path', paramName: 'path' }
    ],
    file_replace_all_text: [
      { type: 'read', path: 'path', paramName: 'path' },
      { type: 'write', path: 'path', paramName: 'path' }
    ],
    file_move: [
      { type: 'read', path: 'old_path', paramName: 'old_path' },
      { type: 'write', path: 'new_path', paramName: 'new_path' }
    ],
    files_read: [{ type: 'read', path: 'paths', paramName: 'paths' }],
    file_read_numbered: [{ type: 'read', path: 'path', paramName: 'path' }],
    file_replace_lines: [
      { type: 'read', path: 'path', paramName: 'path' },
      { type: 'write', path: 'path', paramName: 'path' }
    ],
    dir_create: [{ type: 'write', path: 'path', paramName: 'path' }],
    dir_delete: [{ type: 'write', path: 'path', paramName: 'path' }],
    ls: [{ type: 'read', path: 'path', paramName: 'path' }],
    grep: [{ type: 'read', path: 'path', paramName: 'path' }],
    glob: [{ type: 'read', path: 'base_path', paramName: 'base_path' }]
  };

  constructor(config: FsGuardConfig | undefined, private repoRoot: string) {
    this.allowedPatterns = config?.allowed || [`${repoRoot}/**`];
    this.deniedPatterns = config?.denied || ['/**'];
    this.followSymlinks = config?.followSymlinks ?? false;

    // Resolve relative patterns from repo root
    this.allowedPatterns = this.allowedPatterns.map(p => this.resolvePattern(p));
    this.deniedPatterns = this.deniedPatterns.map(p => this.resolvePattern(p));
  }

  async check(action: LoafAction): Promise<GuardCheckResult> {
    const permissions = FsGuard.ACTION_PERMISSIONS[action.action];
    if (!permissions) {
      // Unknown action - let fs-ops handle it
      return { allowed: true };
    }

    // Check each required permission
    for (const perm of permissions) {
      const paramValue = action.parameters[perm.paramName];
      if (!paramValue) {
        continue; // Let fs-ops handle missing params
      }

      // Handle multi-path parameters (files_read)
      const paths = perm.paramName === 'paths' 
        ? this.parseMultilinePaths(paramValue)
        : [paramValue];

      for (const path of paths) {
        const result = await this.checkPath(path, perm.type);
        if (!result.allowed) {
          return result;
        }
      }
    }

    return { allowed: true };
  }

  private async checkPath(path: string, permType: 'read' | 'write'): Promise<GuardCheckResult> {
    // Canonicalize path if it exists
    let canonicalPath = path;
    try {
      if (this.followSymlinks) {
        canonicalPath = await realpath(path);
      }
    } catch (error: any) {
      // Path doesn't exist yet
      if (permType === 'read') {
        // Can't read non-existent file
        return {
          allowed: false,
          reason: `Path does not exist: ${path}`
        };
      }
      // For writes, check parent directory if file doesn't exist
      try {
        const parent = dirname(path);
        if (this.followSymlinks) {
          canonicalPath = resolve(await realpath(parent), path.split('/').pop()!);
        }
      } catch {
        // Parent doesn't exist either - use non-canonical path
        canonicalPath = resolve(path);
      }
    }

    // Find most specific matching rule
    const allowMatch = this.findMostSpecificMatch(canonicalPath, this.allowedPatterns);
    const denyMatch = this.findMostSpecificMatch(canonicalPath, this.deniedPatterns);

    // If both match, most specific wins
    if (allowMatch && denyMatch) {
      if (allowMatch.specificity >= denyMatch.specificity) {
        return { allowed: true };
      }
    }

    // Deny match takes precedence
    if (denyMatch) {
      return {
        allowed: false,
        reason: `${permType === 'read' ? 'Read' : 'Write'} access denied for '${path}'`
      };
    }

    // Must have an allow match
    if (!allowMatch) {
      return {
        allowed: false,
        reason: `${permType === 'read' ? 'Read' : 'Write'} access denied for '${path}' - no matching allow rule`
      };
    }

    return { allowed: true };
  }

  private findMostSpecificMatch(path: string, patterns: string[]): { pattern: string; specificity: number } | null {
    let bestMatch: { pattern: string; specificity: number } | null = null;

    for (const pattern of patterns) {
      if (minimatch(path, pattern, { dot: true, nonegate: true, nocase: false })) {
        const specificity = this.calculateSpecificity(pattern);
        if (!bestMatch || specificity > bestMatch.specificity) {
          bestMatch = { pattern, specificity };
        }
      }
    }

    return bestMatch;
  }

  private calculateSpecificity(pattern: string): number {
    // Count non-wildcard segments
    const segments = pattern.split('/').filter(s => s.length > 0);
    let specificity = 0;
    
    for (const segment of segments) {
      if (!segment.includes('*') && !segment.includes('?')) {
        specificity += 2; // Exact segment
      } else if (segment === '*') {
        specificity += 0; // Single wildcard
      } else if (segment === '**') {
        specificity += 0; // Recursive wildcard
      } else {
        specificity += 1; // Partial wildcard
      }
    }

    return specificity;
  }

  private resolvePattern(pattern: string): string {
    if (isAbsolute(pattern)) {
      return pattern;
    }
    return resolve(this.repoRoot, pattern);
  }

  private parseMultilinePaths(paths: string): string[] {
    return paths
      .split('\n')
      .map(line => line.trim())
      .filter(line => line.length > 0);
  }
}
=== END FILE: /Users/stuart/repos/loaf/proj/comp/fs-guard/src/FsGuard.ts ===

=== START FILE: /Users/stuart/repos/loaf/proj/comp/instruct-gen/src/index.ts ===
// proj/comp/instruct-gen/src/index.ts
import { loadBaseInstructions } from './loader.js';
import { filterByAllowedTools } from './parser.js';
import { writeFile } from 'fs/promises';
import { join } from 'path';

export async function updateInstructions(
  repoPath: string,
  allowedTools: string[]
): Promise<void> {
  const base = await loadBaseInstructions();
  const filtered = filterByAllowedTools(base, allowedTools);
  const outputPath = join(repoPath, 'NESL_INSTRUCTIONS.md');
  
  await writeFile(outputPath, filtered);
}
=== END FILE: /Users/stuart/repos/loaf/proj/comp/instruct-gen/src/index.ts ===

=== START FILE: /Users/stuart/repos/loaf/proj/comp/instruct-gen/src/loader.ts ===
import { readFile } from 'fs/promises';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';

const __dirname = dirname(fileURLToPath(import.meta.url));
const TEMPLATE_PATH = join(__dirname, '../templates/base-instructions.md');

export async function loadBaseInstructions(): Promise<string> {
  return readFile(TEMPLATE_PATH, 'utf8');
}
=== END FILE: /Users/stuart/repos/loaf/proj/comp/instruct-gen/src/loader.ts ===

=== START FILE: /Users/stuart/repos/loaf/proj/comp/instruct-gen/src/parser.ts ===
import { marked } from 'marked';

export function filterByAllowedTools(
  markdown: string, 
  allowedTools: string[]
): string {
  const allowed = new Set(allowedTools);
  const lines = markdown.split('\n');
  const output: string[] = [];
  
  let inActionSection = false;
  let currentTool: string | null = null;
  let skipCurrentTool = false;
  
  for (const line of lines) {
    // Detect "## Actions" section
    if (line === '## Actions') {
      inActionSection = true;
      output.push(line);
      continue;
    }
    
    // Detect other sections (exit Actions)
    if (inActionSection && line.startsWith('## ') && line !== '## Actions') {
      inActionSection = false;
      skipCurrentTool = false; // Reset skip flag when leaving Actions section
    }
    
    // Process tool headers in Actions section
    if (inActionSection && line.startsWith('### `')) {
      const match = line.match(/^### `([^`]+)`/);
      currentTool = match?.[1] || null;
      skipCurrentTool = currentTool ? !allowed.has(currentTool) : false;
      
      if (skipCurrentTool) continue; // Skip the header line itself
    }
    
    // Skip lines for disallowed tools only within Actions section
    if (!skipCurrentTool || !inActionSection) {
      output.push(line);
    }
  }
  
  return output.join('\n');
}
=== END FILE: /Users/stuart/repos/loaf/proj/comp/instruct-gen/src/parser.ts ===

=== START FILE: /Users/stuart/repos/loaf/proj/comp/fs-ops/src/index.ts ===
/**
 * fs-ops - File system operations executor for loaf
 * 
 * Handles all file and directory operations from parsed NESL actions
 */

import type { LoafAction } from '../../nesl-action-parser/src/index.js';
import type { FsGuard } from '../../fs-guard/src/index.js';

// Import all implemented action handlers
import { handle__file_write } from './actions/file_write.js';
import { handle__file_read } from './actions/file_read.js';
import { handle__file_read_numbered } from './actions/file_read_numbered.js';
import { handle__file_replace_text } from './actions/file_replace_text.js';
import { handle__file_replace_all_text } from './actions/file_replace_all_text.js';
import { handle__file_replace_lines } from './actions/file_replace_lines.js';
import { handle__file_delete } from './actions/file_delete.js';
import { handle__file_move } from './actions/file_move.js';
import { handle__files_read } from './actions/files_read.js';

export interface FileOpResult {
  success: boolean;
  data?: any;
  error?: string;
}

export class FileOpError extends Error {
  constructor(
    message: string,
    public code: string,
    public path?: string,
    public operation?: string
  ) {
    super(message);
    this.name = 'FileOpError';
  }
}

// Actions that are specified but not yet implemented
const NOT_IMPLEMENTED = new Set([
  'dir_create',
  'dir_delete',
  'ls',
  'grep',
  'glob',
  'file_replace_text_range',
  'file_append',
  'exec',
  'context_add',
  'context_remove',
  'context_list',
  'context_prune',
  'context_clear',
  'git_squash',
  'undo',
  'git_step_back',
  'git_step_forward',
  'files_replace_all_text',
  'files_replace_text_in_parents'
]);

/**
 * File system operations executor with security guard
 */
export class FsOpsExecutor {
  private handlers: Map<string, (action: LoafAction) => Promise<FileOpResult>>;

  constructor(private guard: FsGuard) {
    this.handlers = new Map([
      ['file_write', (action) => handle__file_write(this.guard, action)],
      ['file_read', (action) => handle__file_read(this.guard, action)],
      ['file_read_numbered', (action) => handle__file_read_numbered(this.guard, action)],
      ['file_replace_text', (action) => handle__file_replace_text(this.guard, action)],
      ['file_replace_all_text', (action) => handle__file_replace_all_text(this.guard, action)],
      ['file_replace_lines', (action) => handle__file_replace_lines(this.guard, action)],
      ['file_delete', (action) => handle__file_delete(this.guard, action)],
      ['file_move', (action) => handle__file_move(this.guard, action)],
      ['files_read', (action) => handle__files_read(this.guard, action)]
    ]);
  }

  /**
   * Execute a file system operation with guard checks
   */
  async execute(action: LoafAction): Promise<FileOpResult> {
    try {
      // Check fs-guard permissions first
      const guardResult = await this.guard.check(action);
      if (!guardResult.allowed) {
        return {
          success: false,
          error: `fs-guard violation: ${guardResult.reason}`
        };
      }

      const handler = this.handlers.get(action.action);
      if (!handler) {
        // Check if it's a known but not implemented action
        if (NOT_IMPLEMENTED.has(action.action)) {
          return {
            success: false,
            error: `Action not yet implemented: ${action.action}`
          };
        }
        // Truly unknown action
        return {
          success: false,
          error: `Unknown action: ${action.action}`
        };
      }

      return await handler(action);
    } catch (error: any) {
      // This should never happen - handlers should catch their own errors
      return {
        success: false,
        error: `Unexpected error in execute: ${error.message}`
      };
    }
  }
}

/**
 * Legacy function export for backward compatibility
 * @deprecated Use FsOpsExecutor class instead
 */
export async function executeFileOperation(action: LoafAction): Promise<FileOpResult> {
  throw new Error('Direct function call deprecated. Use FsOpsExecutor class.');
}
=== END FILE: /Users/stuart/repos/loaf/proj/comp/fs-ops/src/index.ts ===

=== START FILE: /Users/stuart/repos/loaf/proj/comp/exec/src/ExecExecutor.ts ===
import type { LoafAction } from '../../nesl-action-parser/src/index.js';
import type { FileOpResult } from '../../fs-ops/src/index.js';
import { executeCommand } from './executeCommand.js';

/**
 * Executor for shell/code execution operations
 */
export class ExecExecutor {
  constructor(/* future: execGuard */) {}

  async execute(action: LoafAction): Promise<FileOpResult> {
    if (action.action !== 'exec') {
      return {
        success: false,
        error: `ExecExecutor only handles 'exec' action, got: ${action.action}`
      };
    }

    return executeCommand(action);
  }
}
=== END FILE: /Users/stuart/repos/loaf/proj/comp/exec/src/ExecExecutor.ts ===

=== START FILE: /Users/stuart/repos/loaf/proj/comp/nesl-action-parser/src/types.ts ===
export interface ParseResult {
  actions: LoafAction[];
  errors: ParseError[];
  summary: {
    totalBlocks: number;
    successCount: number;
    errorCount: number;
  };
  debug?: {
    rawInput?: string;
    rawParseResult?: any;
  };
}

export interface LoafAction {
  action: string;
  parameters: Record<string, any>;
  metadata: {
    blockId: string;
    startLine: number;
    endLine: number;
  };
}

export interface ParseError {
  blockId: string;
  action?: string;
  errorType: 'syntax' | 'validation' | 'type';
  message: string;
  blockStartLine?: number;
  neslContent?: string;
}

export interface ValidationResult {
  valid: boolean;
  actionType?: string;
  errors?: string[];
}

export class TransformError extends Error {
  constructor(
    message: string,
    public parameterName: string,
    public expectedType: string,
    public actualValue: string
  ) {
    super(message);
    this.name = 'TransformError';
  }
}

export interface ActionDefinition {
  type: 'read' | 'write' | 'meta' | 'git' | 'dynamic';
  description: string;
  parameters: Record<string, ParameterDef>;
  returns?: Record<string, any>;
}

export interface ParameterDef {
  type: string;
  required: boolean;
  format?: string;
  values?: string[];
  default?: any;
}
=== END FILE: /Users/stuart/repos/loaf/proj/comp/nesl-action-parser/src/types.ts ===

=== START FILE: /Users/stuart/repos/loaf/proj/comp/orch/src/types.ts ===
// Re-export config types from config component
export type { LoafConfig, FsGuardConfig, ExecGuardConfig } from '../../config/src/index.js';
=== END FILE: /Users/stuart/repos/loaf/proj/comp/orch/src/types.ts ===

