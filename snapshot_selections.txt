=== START FILE: /Users/stuart/repos/loaf/unified-design.yaml ===
# AI Coder Tools Schema - Unified Design

# Loaf executes filesystem and runtime commands embedded in LLM output using NESL syntax. It provides deterministic filesystem access and shell command execution for LLM coding agents.

# NESL syntax example:

NESL_synatx_example: |
  ```sh nesl
  #!nesl [@three-char-SHA-256: k7m]
  action = "file_write"
  path = "/tmp/\"hello\".txt"
  content = <<'EOT_k7m'
  Hello world!
  how are you?
  EOT_k7m
  #!end_k7m
  ```


tools:
  # File Operations
  file_write:
    type: write
    executor: fs-ops
    description: Create new file while creating any necessary parent dirs. overwrites if already exists
    accessibility: [llm]
    output_display: never
    primary_param: path
    parameters:
      path: {type: string, required: true, format: absolute_path}
      content: {type: string, required: true}
    returns: {success: boolean, error?: string}
    
  file_replace_text:
    type: write
    executor: fs-ops
    description: Replace first and only instance of substring in file. must exist only once
    accessibility: [llm]
    output_display: never
    primary_param: path
    parameters:
      path: {type: string, required: true, format: absolute_path}
      old_text: {type: string, required: true}
      new_text: {type: string, required: true}
    returns: {success: boolean, replacements_made?: integer, error?: string}
    
  file_replace_text_range:
    type: write
    executor: fs-ops
    description: Replace first and only instance of text range in file. must exist only once
    accessibility: [llm]
    output_display: never
    primary_param: path
    parameters:
      path: {type: string, required: true, format: absolute_path}
      old_text_beginning: {type: string, required: true}
      old_text_end: {type: string, required: true}
      new_text: {type: string, required: true}
    returns: {success: boolean, replacements_made?: integer, error?: string}
    
  file_replace_all_text:
    type: write
    executor: fs-ops
    description: Replace each matching substring in file.  Number of matches (count) should usually be known and declared ahead of time.
    accessibility: [llm]
    output_display: never
    primary_param: path
    parameters:
      path: {type: string, required: true, format: absolute_path}
      old_text: {type: string, required: true}
      new_text: {type: string, required: true}
      count: {type: integer, required: false}
    returns: {success: boolean, replacements_made?: integer, error?: string}
    

  #tentative!  under consideration
  files_replace_all_text:
    type: write
    executor: fs-ops
    description: Replace all occurrences of substring in multiple files. Processes each file independently
    accessibility: [llm]
    parameters:
      paths: {type: string, format: multiline_absolute_paths}
      old_text: {type: string, required: true}
      new_text: {type: string, required: true}
    returns: {
      success: boolean,
      results: {
        type: array,
        items: {
          path: string,
          replacements_made: integer,
          error?: string
        }
      },
      error?: string  # for complete failure
    }



  #tentative!  under consideration.  dont implement yet
  # actually.... for "in parents" stuff lets just use our exisitng tools, but allow "parent" stuff to be added to the path, like ina  syntax we created earlier but forgot about
  # like:
  # path/to/file.md@@## Section 2@@### part 3
  # path/to/code.rs@@MyModuleOrClass@@myFunction
  files_replace_text_in_parents:
    type: write
    executor: fs-ops
    description: Replace all occurrences of substring in a given node of a parsed file that supports grouping, like markdown, code (ast), etc 
    accessibility: [llm]
    parameters:
      path: {type: string, required: true}
      parents: {type: string, required: true, format: multiline_absolute_paths} # need to better define how parents are defined
      old_text: {type: string, required: true}
      new_text: {type: string, required: true}


  file_append:
    type: write
    executor: fs-ops
    description: Append to file
    accessibility: [llm]
    parameters:
      path: {type: string, required: true, format: absolute_path}
      content: {type: string, required: true}
    returns: {success: boolean, error?: string}
    
  file_delete:
    type: write
    executor: fs-ops
    description: Delete file
    accessibility: [llm]
    output_display: never
    primary_param: path
    parameters:
      path: {type: string, required: true, format: absolute_path}
    returns: {success: boolean, error?: string}
    
  file_move:
    type: write
    executor: fs-ops
    description: Move/rename file
    accessibility: [llm]
    output_display: never
    primary_param: old_path
    parameters:
      old_path: {type: string, required: true, format: absolute_path}
      new_path: {type: string, required: true, format: absolute_path}
    returns: {success: boolean, error?: string}
    


  file_read:
    type: read
    executor: fs-ops
    description: Read single file content
    accessibility: [llm]
    output_display: always
    primary_param: path
    parameters:
      path: {type: string, required: true, format: absolute_path}
    returns: {success: boolean, content?: string, error?: string}

  file_read_numbered:
    type: read
    executor: fs-ops
    description: Read file content with line numbers for specified line range
    accessibility: [llm]
    output_display: always
    primary_param: path
    parameters:
      path: {type: string, required: true, format: absolute_path}
      lines: {type: string, required: false, description: "Line range: single '4' or range '23-43'. If omitted, reads all lines."}
      delimiter: {type: string, required: false, default: ": ", description: "Delimiter between line number and content"}
    returns: {success: boolean, content?: string, error?: string}

  file_replace_lines:
    type: write
    executor: fs-ops
    description: Replace specified line range in file with new content
    accessibility: [llm]
    output_display: never
    primary_param: path
    parameters:
      path: {type: string, required: true, format: absolute_path}
      lines: {type: string, required: true, description: "Line range: single '4' or range '23-43'"}
      new_content: {type: string, required: true, description: "Content to replace the line range with"}
    returns: {success: boolean, lines_replaced?: integer, error?: string}


  files_read:
    type: read
    executor: fs-ops
    description: Read and concatenate contents of multiple files into a single string, with clear file delimiters
    accessibility: [llm]
    output_display: always
    primary_param: paths
    parameters:
      paths: {
        type: string, 
        required: true, 
        format: "multiline_absolute_paths",
        description: "One absolute file path per line. Empty lines are ignored."
      }
    returns: {
      success: boolean, 
      data?: {                          # i guess this is formatted wrong... 
        paths: array, content: array
        },
      error?: string
    }  
    example: |
      paths: |
        /home/user/projects/src/main.py
        /home/user/projects/src/utils.py
        /home/user/projects/README.md
    
  # Directory Operations
  dir_create:
    type: write
    executor: fs-ops
    description: Create directory
    accessibility: [llm]
    output_display: never
    primary_param: path
    parameters:
      path: {type: string, required: true, format: absolute_path}
    returns: {success: boolean, error?: string}
    
  dir_delete:
    type: write
    executor: fs-ops
    description: Delete directory
    accessibility: [llm]
    output_display: never
    primary_param: path
    parameters:
      path: {type: string, required: true, format: absolute_path}
    returns: {success: boolean, error?: string}
    
  # Read Operations
  ls:
    type: read
    executor: fs-ops
    description: List directory contents
    accessibility: [llm]
    output_display: always
    primary_param: path
    parameters:
      path: {type: string, required: true, format: absolute_path}
    returns: 
      success: boolean
      data:
        type: array
        items:
          name: string
          type: string  # file|directory
          size: integer
          modified: timestamp
      error: string
    
  grep:
    type: read
    description: Search pattern in files
    accessibility: [llm]
    output_display: always
    primary_param: pattern
    parameters:
      pattern: {type: string, required: true}
      path: {type: string, required: true, format: absolute_path}
      include: {type: string, required: false}
    returns: 
      success: boolean
      data:
        type: array
        items:
          file: string
          line_number: integer
          line: string
      error: string
    
  glob:
    type: read
    description: Find files matching pattern
    accessibility: [llm]
    output_display: always
    primary_param: pattern
    parameters:
      pattern: {type: string, required: true}
      base_path: {type: string, required: true, format: absolute_path}
    returns: 
      success: boolean
      data:
        type: array
        items: string
      error: string
    
  # Execution
  exec:
    type: dynamic
    description: Execute code
    accessibility: [llm]
    output_display: conditional  # Check return_output parameter
    primary_param: lang
    parameters:
      code: {type: string, required: true}
      lang: {type: enum, values: [python, javascript, bash], required: true}
      version: {type: string, required: false}
      cwd: {type: string, required: false, format: absolute_path}
      return_output: {type: boolean, required: false, default: true}
    returns: {success: boolean, stdout?: string, stderr?: string, exit_code?: integer, error?: string}

  # Context Operations -- for much later.  dont do this until loaf has been integrated into bigfoot, the ai llm coder
  context_add:
    type: meta
    description: Add item to working context (persistent)
    accessibility: [llm, user]
    parameters:
      path: {type: string, required: true, format: absolute_path}
    returns: {success: boolean, error?: string}
      
  context_remove:
    type: meta
    description: Remove item from working context
    accessibility: [llm, user]
    parameters:
      path: {type: string, required: true, format: absolute_path}
    returns: {success: boolean, error?: string}
      
  context_list:
    type: meta
    description: List items in working context
    accessibility: [llm, user]
    parameters: {}
    returns: 
      success: boolean
      data:
        type: array
        items:
          path: string
          size: integer
      error: string
    
  context_prune:
    type: meta
    description: Remove unused items from working context
    accessibility: [llm, user]
    parameters: {}
    returns: {success: boolean, removed?: array of strings, error?: string}
    
  context_clear:
    type: meta
    description: Clear all working context items
    accessibility: [llm, user]
    parameters: {}
    returns: {success: boolean, error?: string}
    
  # Git Operations
  git_squash:
    type: git
    description: Squash commits
    slash_command: true
    parameters:
      mode: {type: enum, values: [auto_ai, ai_messages, hours, days, contiguous_only=true, msg_contains], required: true}
      message: {type: string, required: false}
      hours: {type: integer, required: false, when: "mode=hours"}
      days: {type: integer, required: false, when: "mode=days"}
      msg_target: {type: string, required: false, when: "mode=msg_contains"}
    returns: {success: boolean, error?: string}
      
  undo:
    type: git
    description: Undo last AI changes
    accessibility: [user]
    constraints: ["No changes since last AI operation"]
    parameters: {}
    returns: {success: boolean, error?: string}
    
  git_step_back:
    type: git
    description: Move to previous commit
    accessibility: [user]
    behavior: Stashes untracked changes
    parameters: {}
    returns: {success: boolean, stashed_files?: array of strings, error?: string}
    
  git_step_forward:
    type: git
    description: Move to next commit
    accessibility: [user]
    behavior: Attempts to pop stashed changes
    parameters: {}
    returns: {success: boolean, conflicts?: array of strings, error?: string}

# Transaction Management
transaction_model:
  strategy: operation_group
  conflict_detection:
    methods:
      - mtime comparison (fast but unreliable)
      - checksum comparison (slower but accurate)
      - git status check (catches git-tracked changes)
    timing:
      - Check immediately before operation group
      - Check after each write operation
      - Final check before commit
  implementation:
    - Begin: git commit current state
    - Execute: track all operations
    - Validate: check for external modifications
    - Success: git commit with summary
    - Failure: git reset --hard to start
  atomicity: none  # Git operations are NOT atomic at filesystem level
  
# Security Model
security:
  path_validation:
    type: allowlist
    allowed_roots:
      - /home/user/projects
      - /tmp/ai-coder
    blacklist_patterns:
      - .*\.ssh.*
      - .*\.git/config
      - /etc/.*
      - /sys/.*
      - /proc/.*
  canonicalization: required  # Resolve ../ and symlinks before checking
  
# System Configuration
config:
  encoding: utf-8
  line_endings: preserve  # Don't normalize
  max_file_size: 10485760  # 10MB
  git_auto_push: false  # Require explicit push
  commit_message_format: "AI: {operation_summary}"

TODO: |   
  Transaction Safety: The git-based transaction model has race conditions:

    Gap between "git commit" and first operation
    Non-atomic filesystem ops vs git state


# more TODO 


  #tentative!  under consideration.  dont implement yet
  # actually.... for "in parents" stuff lets just use our exisitng tools, but allow "parent" stuff to be added to the path, like ina  syntax we created earlier but forgot about
  # like:
  # path/to/file.md@@## Section 2@@### part 3
  # path/to/code.rs@@MyModuleOrClass@@myFunction

  # and add a wayt o get file numbers per read.  like an attribute to add to file_read to get the text with line numbers. and then a file_lines_replace that takes in a line range and replacement_text params. or maybe even each as an array.  maybe we should just change nesl-js so its not an error to have repeated values.  cos right now its like impossible to make a lot of small changes to a big code file.  but if we new the line number per each... that would make it easy for LLM... 
=== END FILE: /Users/stuart/repos/loaf/unified-design.yaml ===

=== START FILE: /Users/stuart/repos/loaf/proj/comp/orch/src/index.ts ===
import type { LoafAction, ParseResult, ParseError } from '../../nesl-action-parser/src/index.js';
import { parseNeslResponse } from '../../nesl-action-parser/src/index.js';
import type { FileOpResult } from '../../fs-ops/src/index.js';
import type { HooksConfig, HookContext, HookResult } from '../../hooks/src/index.js';
import { HooksManager } from '../../hooks/src/index.js';
import { load as loadYaml } from 'js-yaml';
import { readFile, access } from 'fs/promises';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';
import { createStarterConfig } from './createStarterConfig.js';

export interface ExecutionResult {
  success: boolean;
  totalBlocks: number;
  executedActions: number;
  results: ActionResult[];
  parseErrors: ParseError[];
  fatalError?: string;
  hookErrors?: {
    before?: string[];
    after?: string[];
  };
  configCreated?: boolean;
  debug?: {
    parseDebug?: any;
  };
}

export interface ActionResult {
  seq: number;
  blockId: string;
  action: string;
  params: Record<string, any>;
  success: boolean;
  error?: string;
  data?: any;
}

export interface LoafOptions {
  repoPath?: string;
  gitCommit?: boolean;
  hooks?: HooksConfig;
  enableHooks?: boolean;
  createConfigIfMissing?: boolean;
}

export class Loaf {
  private options: LoafOptions;
  private executors: Map<string, (action: LoafAction) => Promise<FileOpResult>> | null = null;
  private hooksManager: HooksManager | null = null;

  constructor(options: LoafOptions = {}) {
    this.options = {
      repoPath: options.repoPath || process.cwd(),
      gitCommit: options.gitCommit ?? true,
      hooks: options.hooks,
      enableHooks: options.enableHooks ?? true,
      createConfigIfMissing: options.createConfigIfMissing ?? false
    };
  }

  /**
   * Parse and execute all NESL blocks in LLM output
   * Executes all valid actions sequentially, collecting both successes and failures
   */
  async execute(llmOutput: string): Promise<ExecutionResult> {
    const hookErrors: ExecutionResult['hookErrors'] = {};
    let configCreated = false;

    try {
      // Initialize hooks if enabled and not already initialized
      if (this.options.enableHooks && !this.hooksManager) {
        try {
          const initResult = await this.initializeHooks();
          configCreated = initResult.configCreated || false;
        } catch (error) {
          return {
            success: false,
            totalBlocks: 0,
            executedActions: 0,
            results: [],
            parseErrors: [],
            fatalError: `Failed to initialize hooks: ${error instanceof Error ? error.message : String(error)}`
          };
        }
      }

      // Run before hooks
      if (this.hooksManager) {
        try {
          const beforeResult = await this.hooksManager.runBefore();
          if (!beforeResult.success) {
            // Before hook failure is fatal
            return {
              success: false,
              totalBlocks: 0,
              executedActions: 0,
              results: [],
              parseErrors: [],
              hookErrors: {
                before: beforeResult.errors?.map(e => `${e.command}: ${e.error}`) || ['Unknown before hook error']
              },
              fatalError: 'Before hooks failed - aborting execution'
            };
          }
        } catch (error) {
          return {
            success: false,
            totalBlocks: 0,
            executedActions: 0,
            results: [],
            parseErrors: [],
            fatalError: `Before hooks threw unexpected error: ${error instanceof Error ? error.message : String(error)}`
          };
        }
      }

      // Parse NESL blocks
      const parseResult = await parseNeslResponse(llmOutput);

      // Debug info captured in parseResult.debug

      // Initialize executors if needed
      if (!this.executors) {
        try {
          await this.initializeExecutors();
        } catch (error) {
          return {
            success: false,
            totalBlocks: parseResult.summary.totalBlocks,
            executedActions: 0,
            results: [],
            parseErrors: parseResult.errors,
            fatalError: `Failed to initialize executors: ${error instanceof Error ? error.message : String(error)}`
          };
        }
      }

      // Execute each valid action sequentially
      const results: ActionResult[] = [];
      let seq = 1;

      for (const action of parseResult.actions) {
        const result = await this.executeAction(action, seq++);
        results.push(result);
      }

      // Calculate execution success (before considering after hooks)
      const allActionsSucceeded = results.every(r => r.success);
      const noParseErrors = parseResult.errors.length === 0;
      const executionSuccess = allActionsSucceeded && noParseErrors;

      // Run after hooks with context
      if (this.hooksManager) {
        try {
          // Build rich context for hooks
          const modifiedFiles = new Set<string>();
          const operations: string[] = [];
          const errors: string[] = [];

          for (const result of results) {
            if (result.action.startsWith('file_') && result.params.path) {
              modifiedFiles.add(result.params.path);
            }

            operations.push(`${result.action}${result.success ? '' : ' (failed)'}`);

            if (!result.success && result.error) {
              errors.push(`${result.action}: ${result.error}`);
            }
          }

          const afterContext: HookContext = {
            success: executionSuccess,
            executedActions: results.length,
            totalBlocks: parseResult.summary.totalBlocks,
            modifiedFiles: Array.from(modifiedFiles).join(','),
            operations: operations.join(','),
            errors: errors.join('; '),
            errorCount: errors.length
          };

          const afterResult = await this.hooksManager.runAfter(afterContext);
          if (!afterResult.success) {
            // After hook failure is non-fatal but recorded
            hookErrors.after = afterResult.errors?.map(e => `${e.command}: ${e.error}`) || ['Unknown after hook error'];
          }
        } catch (error) {
          // After hook unexpected errors are also non-fatal
          hookErrors.after = [`After hooks threw unexpected error: ${error instanceof Error ? error.message : String(error)}`];
        }
      }

      return {
        success: executionSuccess && !hookErrors.after, // After hook errors affect overall success
        totalBlocks: parseResult.summary.totalBlocks,
        executedActions: results.length,
        results,
        parseErrors: parseResult.errors,
        ...(Object.keys(hookErrors).length > 0 && { hookErrors }),
        ...(configCreated && { configCreated }),
        debug: {
          parseDebug: parseResult.debug
        }
      };

    } catch (error) {
      // Only truly unexpected errors should reach here
      return {
        success: false,
        totalBlocks: 0,
        executedActions: 0,
        results: [],
        parseErrors: [],
        fatalError: `Unexpected error in execute: ${error instanceof Error ? error.message : String(error)}`
      };
    }
  }

  /**
   * Initialize hooks manager with configuration
   * Loads from options or loaf.yml file
   */
  private async initializeHooks(): Promise<{ configCreated: boolean }> {
    let configCreated = false;

    if (this.options.hooks) {
      // Use provided configuration
      // Wrap the hooks in the expected HooksConfig structure
      const hooksConfig: HooksConfig = {
        hooks: this.options.hooks,
        vars: {}
      };
      this.hooksManager = new HooksManager(hooksConfig, this.options.repoPath);
    } else {
      // Try to load from loaf.yml
      const loafYmlPath = join(this.options.repoPath!, 'loaf.yml');
      try {
        await access(loafYmlPath);
        this.hooksManager = new HooksManager(undefined, this.options.repoPath);
        await this.hooksManager.loadAndSetConfig(loafYmlPath);
        // Don't create a new instance - loadAndSetConfig updates the existing one
      } catch (error: any) {
        if (error.code === 'ENOENT' && this.options.createConfigIfMissing) {
          // Create starter config
          configCreated = await createStarterConfig(this.options.repoPath!);
          if (configCreated) {
            // Load the newly created config
            this.hooksManager = new HooksManager(undefined, this.options.repoPath);
            await this.hooksManager.loadAndSetConfig(loafYmlPath);
          }
        }
        // If not ENOENT or createConfigIfMissing is false, hooks remain disabled
      }
    }

    return { configCreated };
  }

  /**
   * Initialize action executors with dynamic imports
   * Loads routing from unified-design.yaml
   */
  private async initializeExecutors(): Promise<void> {
    this.executors = new Map();

    // Load unified-design.yaml
    const __filename = fileURLToPath(import.meta.url);
    const __dirname = dirname(__filename);
    const yamlPath = join(__dirname, '../../../../unified-design.yaml');
    const yamlContent = await readFile(yamlPath, 'utf8');
    const design = loadYaml(yamlContent) as any;

    // Map executor names to modules
    const executorModules: Record<string, () => Promise<any>> = {
      'fs-ops': () => import('../../fs-ops/src/index.js'),
      'exec': () => import('../../exec/src/index.js')
    };

    // Load executors on demand
    const loadedExecutors: Record<string, (action: LoafAction) => Promise<FileOpResult>> = {};

    // Build routing table from YAML
    for (const [actionName, actionDef] of Object.entries(design.tools)) {
      const executor = (actionDef as any).executor || this.inferExecutor(actionName, actionDef);

      if (!executor) {
        console.warn(`No executor defined for action: ${actionName}`);
        continue;
      }

      // Load executor module if not already loaded
      if (!loadedExecutors[executor]) {
        if (executorModules[executor]) {
          const module = await executorModules[executor]();
          // Handle different export names
          if (executor === 'exec') {
            loadedExecutors[executor] = module.executeCommand;
          } else {
            loadedExecutors[executor] = module.executeFileOperation || module.executeOperation;
          }
        } else {
          // Skip planned but unimplemented executors silently
          if (!['context', 'git'].includes(executor)) {
            console.warn(`Unknown executor: ${executor}`);
          }
          continue;
        }
      }

      this.executors.set(actionName, loadedExecutors[executor]);
    }
  }

  /**
   * Infer executor from action name/type when not explicitly defined
   * Temporary fallback until all YAML entries have executor field
   */
  private inferExecutor(actionName: string, actionDef: any): string | null {
    // File/dir operations go to fs-ops
    if (actionName.startsWith('file_') || actionName.startsWith('files_') ||
      actionName.startsWith('dir_') || ['ls', 'grep', 'glob'].includes(actionName)) {
      return 'fs-ops';
    }

    // Exec operations
    if (actionName === 'exec') {
      return 'exec';
    }

    // Context operations (future)
    if (actionName.startsWith('context_')) {
      return 'context';
    }

    // Git operations (future)
    if (actionName.startsWith('git_') || actionName === 'undo') {
      return 'git';
    }

    return null;
  }

  /**
   * Execute a single action and format the result
   * Never throws - all errors returned in ActionResult
   */
  private async executeAction(action: LoafAction, seq: number): Promise<ActionResult> {
    const executor = this.executors?.get(action.action);

    if (!executor) {
      return {
        seq,
        blockId: action.metadata.blockId,
        action: action.action,
        params: action.parameters,
        success: false,
        error: `Unknown action: ${action.action}`
      };
    }

    try {
      // Add default cwd for exec actions if not specified
      const enhancedAction = action.action === 'exec' && !action.parameters.cwd
        ? { ...action, parameters: { ...action.parameters, cwd: this.options.repoPath } }
        : action;

      const result = await executor(enhancedAction);

      return {
        seq,
        blockId: action.metadata.blockId,
        action: action.action,
        params: action.parameters,
        success: result.success,
        ...(result.error && { error: result.error }),
        ...(result.data !== undefined && { data: result.data }),
        // Include exec-specific fields at top level
        ...(action.action === 'exec' && {
          data: {
            stdout: result.stdout,
            stderr: result.stderr,
            exit_code: result.exit_code
          }
        })
      };

    } catch (error) {
      // Executors should never throw, but handle just in case
      return {
        seq,
        blockId: action.metadata.blockId,
        action: action.action,
        params: action.parameters,
        success: false,
        error: `Unexpected executor error: ${error instanceof Error ? error.message : String(error)}`
      };
    }
  }
}
=== END FILE: /Users/stuart/repos/loaf/proj/comp/orch/src/index.ts ===

=== START FILE: /Users/stuart/repos/loaf/proj/comp/fs-ops/src/index.ts ===
/**
 * fs-ops - File system operations executor for loaf
 * 
 * Handles all file and directory operations from parsed NESL actions
 */

import type { LoafAction } from '../../nesl-action-parser/src/index.js';
import { writeFile, mkdir, unlink, rename, readFile } from 'fs/promises';
import { dirname } from 'path';
import { formatNodeError } from './formatNodeError.js';
import { fileExists } from './fileSystemUtils.js';
import { replaceText } from './replaceText.js';
import { extractNumberedLines } from './extractNumberedLines.js';

export interface FileOpResult {
  success: boolean;
  data?: any;
  error?: string;
}

export class FileOpError extends Error {
  constructor(
    message: string,
    public code: string,
    public path?: string,
    public operation?: string
  ) {
    super(message);
    this.name = 'FileOpError';
  }
}

/**
 * Execute a file system operation from a parsed NESL action
 * Never throws - all errors returned in result
 */
export async function executeFileOperation(action: LoafAction): Promise<FileOpResult> {
  try {
    const handler = actionHandlers[action.action];



    if (!handler) {
      return {
        success: false,
        error: `Unknown action: ${action.action}`
      };
    }

    const result = await handler(action);
    return result;

  } catch (error: any) {
    // This should never happen - handlers should catch their own errors
    return {
      success: false,
      error: `Unexpected error in executeFileOperation: ${error.message}`
    };
  }
}

/**
 * Handle file_move action - moves/renames a file
 * Creates parent directories for destination if needed
 * Overwrites destination if it exists
 */
async function handleFileMove(action: LoafAction): Promise<FileOpResult> {
  const { old_path, new_path } = action.parameters;

  try {
    // Pre-flight check for better error messages
    const sourceExists = await fileExists(old_path);

    if (!sourceExists) {
      return {
        success: false,
        error: `file_move: Source file not found '${old_path}' (ENOENT)`
      };
    }

    // Check if destination exists (for overwrote flag)
    const destExists = await fileExists(new_path);

    // Create parent directories for destination
    const parentDir = dirname(new_path);
    await mkdir(parentDir, { recursive: true });

    // Move the file
    await rename(old_path, new_path);

    const result: FileOpResult = {
      success: true,
      data: {
        old_path,
        new_path
      }
    };

    if (destExists) {
      result.data.overwrote = true;
    }

    return result;

  } catch (error: any) {
    return {
      success: false,
      error: formatNodeError(error, old_path, 'rename', new_path)
    };
  }
}

/**
 * Handle file_delete action - removes a file
 */
async function handleFileDelete(action: LoafAction): Promise<FileOpResult> {
  const { path } = action.parameters;

  try {
    await unlink(path);

    return {
      success: true,
      data: {
        path
      }
    };

  } catch (error: any) {
    return {
      success: false,
      error: formatNodeError(error, path, 'unlink')
    };
  }
}

/**
 * Handle file_write action - writes/creates/overwrites a file with content
 * Automatically creates parent directories if needed
 */
async function handleFileWrite(action: LoafAction): Promise<FileOpResult> {
  const { path, content } = action.parameters;

  try {
    // Create parent directories if needed
    const parentDir = dirname(path);
    await mkdir(parentDir, { recursive: true });

    // Write file
    await writeFile(path, content, 'utf8');
    const bytesWritten = Buffer.byteLength(content, 'utf8');

    // Temporary debug for test 004
    if (path.includes('move-to-existing-file')) {
      // console.log(`DEBUG: Wrote file ${path}`);
      const exists = await fileExists(path);
      // console.log(`DEBUG: File exists after write: ${exists}`);
    }

    return {
      success: true,
      data: {
        path,
        bytesWritten
      }
    };

  } catch (error: any) {
    return {
      success: false,
      error: formatNodeError(error, path, 'open')
    };
  }
}

/**
 * Handle file_read action - reads file content
 */
async function handleFileRead(action: LoafAction): Promise<FileOpResult> {
  const { path } = action.parameters;

  try {
    const content = await readFile(path, 'utf8');

    return {
      success: true,
      data: {
        path,
        content
      }
    };

  } catch (error: any) {
    return {
      success: false,
      error: formatNodeError(error, path, 'open')
    };
  }
}

/**
 * Handle file_read_numbered action - reads file content with line numbers
 * Returns specified lines with line numbers prepended
 * If lines parameter is missing, reads all lines
 * If some lines are out of range, returns available content with error
 */
async function handleFileReadNumbered(action: LoafAction): Promise<FileOpResult> {
  const { path, lines, delimiter = ": " } = action.parameters;

  try {
    const content = await readFile(path, 'utf8');

    // Extract and number the requested lines
    const { result, outOfRange } = extractNumberedLines(content, lines, delimiter);

    // If out of range, return error with partial content
    if (outOfRange) {
      return {
        success: false,
        error: `file_read_numbered: Requested lines ${outOfRange.requested} but file only has ${outOfRange.actual} lines`,
        data: {
          path,
          content: result
        }
      };
    }

    return {
      success: true,
      data: {
        path,
        content: result
      }
    };

  } catch (error: any) {
    // Check if it's our custom validation error
    if (error.message && error.message.startsWith('Invalid line')) {
      return {
        success: false,
        error: `file_read_numbered: ${error.message}`
      };
    }

    return {
      success: false,
      error: formatNodeError(error, path, 'open')
    };
  }
}

/**
 * Handle file_replace_lines action - replaces specified lines in a file
 * Supports single line ("4") or range ("23-43") specifications
 * Preserves line endings and handles edge cases
 */
async function handleFileReplaceLines(action: LoafAction): Promise<FileOpResult> {
  const { path, lines, new_content } = action.parameters;

  try {
    // Read existing file content
    const content = await readFile(path, 'utf8');

    // Handle empty file edge case
    if (content === '') {
      return {
        success: false,
        error: `file_replace_lines: Line range ${lines} is out of bounds (file has 0 lines)`
      };
    }

    // Split into lines, preserving empty lines
    // Check if content ends with a newline
    const endsWithNewline = content.match(/\r?\n$/);
    const fileLines = content.split(/\r?\n|\r/);

    // If the file ends with a newline, split gives us an extra empty element
    // Remove it for line counting, but remember it existed
    if (endsWithNewline && fileLines[fileLines.length - 1] === '') {
      fileLines.pop();
    }

    const totalLines = fileLines.length;

    // Parse line specification
    let startLine: number;
    let endLine: number;

    if (!lines || lines === '') {
      return {
        success: false,
        error: `file_replace_lines: Invalid line specification '${lines}'`
      };
    }

    if (lines.includes('-')) {
      // Range format: "23-43"
      const parts = lines.split('-');
      if (parts.length !== 2) {
        return {
          success: false,
          error: `file_replace_lines: Invalid line specification '${lines}'`
        };
      }

      startLine = parseInt(parts[0], 10);
      endLine = parseInt(parts[1], 10);

      if (isNaN(startLine) || isNaN(endLine)) {
        return {
          success: false,
          error: `file_replace_lines: Invalid line specification '${lines}'`
        };
      }

      if (startLine < 1 || endLine < 1) {
        return {
          success: false,
          error: `file_replace_lines: Invalid line specification '${lines}'`
        };
      }

      if (startLine > endLine) {
        return {
          success: false,
          error: `file_replace_lines: Invalid line range '${lines}' (start must be <= end)`
        };
      }
    } else {
      // Single line format: "4"
      startLine = parseInt(lines, 10);
      if (isNaN(startLine) || startLine < 1) {
        return {
          success: false,
          error: `file_replace_lines: Invalid line specification '${lines}'`
        };
      }
      endLine = startLine;
    }



    // Check if lines are out of range
    if (startLine > totalLines || endLine > totalLines) {
      return {
        success: false,
        error: `file_replace_lines: Line range ${lines} is out of bounds (file has ${totalLines} lines)`
      };
    }

    // Split new content into lines
    // Empty content should produce one empty line, not zero lines
    const newLines = new_content.split(/\r?\n|\r/);

    // Reconstruct the file with replaced lines
    const resultLines: string[] = [];

    // Add lines before the replacement range
    for (let i = 0; i < startLine - 1; i++) {
      resultLines.push(fileLines[i]);
    }

    // Add the new content
    resultLines.push(...newLines);

    // Add lines after the replacement range
    for (let i = endLine; i < totalLines; i++) {
      resultLines.push(fileLines[i]);
    }

    // Join back with newlines
    let result = resultLines.join('\n');

    // If the original file ended with a newline, preserve it
    if (endsWithNewline) {
      result += '\n';
    }

    // Write the file back
    await writeFile(path, result, 'utf8');

    const linesReplaced = endLine - startLine + 1;

    return {
      success: true,
      data: {
        path,
        lines_replaced: linesReplaced
      }
    };

  } catch (error: any) {
    return {
      success: false,
      error: formatNodeError(error, path, 'open')
    };
  }
}

/**
 * Handle files_read action - reads multiple files and returns their contents
 * Parses multi-line paths parameter, one absolute path per line
 * Returns an array of file contents in the same order as the paths
 */
async function handleFilesRead(action: LoafAction): Promise<FileOpResult> {
  const { paths } = action.parameters;

  // Parse the multi-line paths string
  const pathList = paths
    .split('\n')
    .map(line => line.trim())
    .filter(line => line.length > 0);  // Remove empty lines

  if (pathList.length === 0) {
    return {
      success: false,
      error: 'files_read: No paths provided'
    };
  }

  // Read all files, collecting content and errors
  const results: Array<{ path: string; content?: string; error?: string }> = [];

  for (const filePath of pathList) {
    try {
      const content = await readFile(filePath, 'utf8');
      results.push({ path: filePath, content });
    } catch (error: any) {
      // Collect error for this file
      const errorMsg = formatNodeError(error, filePath, 'open');
      results.push({ path: filePath, error: errorMsg });
    }
  }

  // Check if any files failed to read
  const failedFiles = results.filter(r => r.error);
  if (failedFiles.length > 0) {
    // Return error listing all failed files
    const errorDetails = failedFiles
      .map(f => `  ${f.path}: ${f.error}`)
      .join('\n');
    return {
      success: false,
      error: `files_read: Failed to read ${failedFiles.length} file(s):\n${errorDetails}`
    };
  }

  // All files read successfully - return contents as array
  const contents = results.map(r => r.content!);

  return {
    success: true,
    data: {
      paths: pathList,
      content: contents
    }
  };
}

/**
 * Handle file_replace_text action - replaces EXACTLY ONE occurrence
 * Fails if old_text appears 0 or 2+ times
 */
async function handleFileReplaceText(action: LoafAction): Promise<FileOpResult> {
  const { path, old_text, new_text } = action.parameters;

  // Validate old_text is not empty
  if (!old_text || old_text.length === 0) {
    return {
      success: false,
      error: 'file_replace_text: old_text cannot be empty'
    };
  }

  try {
    // Read existing file content
    const content = await readFile(path, 'utf8');

    // Count occurrences first
    let count = 0;
    let searchIndex = 0;
    while (true) {
      const index = content.indexOf(old_text, searchIndex);
      if (index === -1) break;
      count++;
      searchIndex = index + old_text.length;
    }

    // Validate exactly one occurrence
    if (count === 0) {
      return {
        success: false,
        error: `file_replace_text: old_text not found in file`
      };
    }
    if (count > 1) {
      return {
        success: false,
        error: `file_replace_text: old_text appears ${count} times, must appear exactly once`
      };
    }

    // Replace the single occurrence
    const { result, replacements } = replaceText(content, old_text, new_text, 1);

    // Write updated content back
    await writeFile(path, result, 'utf8');

    return {
      success: true,
      data: {
        path,
        replacements
      }
    };

  } catch (error: any) {
    // Special case for empty old_text validation error
    if (error.message === 'old_text cannot be empty') {
      return {
        success: false,
        error: 'file_replace_text: old_text cannot be empty'
      };
    }

    return {
      success: false,
      error: formatNodeError(error, path, 'open')
    };
  }
}

/**
 * Handle file_replace_all_text action - replaces all occurrences
 * If count provided, validates exact match
 */
async function handleFileReplaceAllText(action: LoafAction): Promise<FileOpResult> {
  const { path, old_text, new_text, count } = action.parameters;

  // Validate old_text is not empty
  if (!old_text || old_text.length === 0) {
    return {
      success: false,
      error: 'file_replace_all_text: old_text cannot be empty'
    };
  }

  try {
    // Read existing file content
    const content = await readFile(path, 'utf8');

    // If count specified, validate it matches actual occurrences
    if (count !== undefined) {
      // Count actual occurrences
      let actualCount = 0;
      let searchIndex = 0;
      while (true) {
        const index = content.indexOf(old_text, searchIndex);
        if (index === -1) break;
        actualCount++;
        searchIndex = index + old_text.length;
      }

      if (actualCount !== count) {
        return {
          success: false,
          error: `file_replace_all_text: expected ${count} occurrences but found ${actualCount}`
        };
      }
    }

    // Replace all occurrences
    const { result, replacements } = replaceText(content, old_text, new_text);

    // Write updated content back
    await writeFile(path, result, 'utf8');

    return {
      success: true,
      data: {
        path,
        replacements
      }
    };

  } catch (error: any) {
    // Special case for empty old_text validation error
    if (error.message === 'old_text cannot be empty') {
      return {
        success: false,
        error: 'file_replace_all_text: old_text cannot be empty'
      };
    }

    return {
      success: false,
      error: formatNodeError(error, path, 'open')
    };
  }
}

// Internal function stubs for each operation

async function createFile(path: string, content: string): Promise<void> {
  throw new Error('Not implemented');
}



async function replaceTextInFile(path: string, oldText: string, newText: string, count?: number): Promise<number> {
  throw new Error('Not implemented');
}

async function deleteFile(path: string): Promise<void> {
  throw new Error('Not implemented');
}

async function moveFile(oldPath: string, newPath: string): Promise<void> {
  throw new Error('Not implemented');
}

async function readFileContent(path: string): Promise<string> {
  throw new Error('Not implemented');
}

async function createDirectory(path: string): Promise<void> {
  throw new Error('Not implemented');
}

async function deleteDirectory(path: string): Promise<void> {
  throw new Error('Not implemented');
}

interface DirEntry {
  name: string;
  type: 'file' | 'directory';
  size: number;
  modified: Date;
}

async function listDirectory(path: string): Promise<DirEntry[]> {
  throw new Error('Not implemented');
}

interface GrepResult {
  file: string;
  line_number: number;
  line: string;
}

async function searchFiles(pattern: string, path: string, include?: string): Promise<GrepResult[]> {
  throw new Error('Not implemented');
}

async function globFiles(pattern: string, basePath: string): Promise<string[]> {
  throw new Error('Not implemented');
}

// Action handler mapping
const actionHandlers: Record<string, (action: LoafAction) => Promise<FileOpResult>> = {
  'file_write': handleFileWrite,
  'file_replace_text': handleFileReplaceText,
  'file_replace_all_text': handleFileReplaceAllText,
  'file_delete': handleFileDelete,
  'file_move': handleFileMove,
  'file_read': handleFileRead,
  'files_read': handleFilesRead,
  'file_read_numbered': handleFileReadNumbered,
  'file_replace_lines': handleFileReplaceLines,
  'dir_create': async (action) => {
    return { success: false, error: 'Not implemented' };
  },
  'dir_delete': async (action) => {
    return { success: false, error: 'Not implemented' };
  },
  'ls': async (action) => {
    return { success: false, error: 'Action not implemented: ls' };
  },
  'grep': async (action) => {
    return { success: false, error: 'Not implemented' };
  },
  'glob': async (action) => {
    return { success: false, error: 'Not implemented' };
  }
};
=== END FILE: /Users/stuart/repos/loaf/proj/comp/fs-ops/src/index.ts ===

=== START FILE: /Users/stuart/repos/loaf/proj/comp/exec/src/index.ts ===
// Re-export all public functions
export { executeCommand } from './executeCommand';
export { mapLanguageToCommand } from './mapLanguageToCommand';
export { buildSpawnOptions } from './buildSpawnOptions';
export { formatExecResult } from './formatExecResult';

// Re-export types
export type { ExecResult } from './types';
=== END FILE: /Users/stuart/repos/loaf/proj/comp/exec/src/index.ts ===

=== START FILE: /Users/stuart/repos/loaf/proj/comp/exec/src/executeCommand.ts ===
import { spawn } from 'child_process';
import type { ExecResult } from './types';
import { ExecError } from './types';
import { mapLanguageToCommand } from './mapLanguageToCommand';
import { buildSpawnOptions } from './buildSpawnOptions';
import { formatExecResult } from './formatExecResult';

/**
 * Executes code from parsed NESL action in specified language
 * @param action - LoafAction with exec action and parameters
 * @returns ExecResult with success status, output, and exit code
 * Never throws - all errors captured in result
 */
export async function executeCommand(action: any): Promise<ExecResult> {
  try {
    // Validate action structure
    if (!action?.parameters?.lang || !action?.parameters?.code === undefined) {
      return formatExecResult(null, '', '',
        new Error('Invalid action: missing lang or code parameter'));
    }

    const { lang, code, cwd, timeout } = action.parameters;

    // Map language to command (may throw)
    const { command, args } = mapLanguageToCommand(lang, code);

    // Build spawn options with validated cwd (may throw)
    const options = await buildSpawnOptions(cwd);

    // Execute command and capture results
    return await runProcess(command, args, options, timeout);

  } catch (error) {
    // Convert exceptions to ExecResult format
    if (error instanceof ExecError) {
      return formatExecResult(null, '', '', error);
    }
    return formatExecResult(null, '', '',
      error instanceof Error ? error : new Error(String(error)));
  }
}

/**
 * Spawns child process and captures output with timeout handling
 * @param command - Interpreter command to run
 * @param args - Arguments for the command
 * @param options - Spawn options including cwd and timeout
 * @returns ExecResult with captured output and exit code
 */
async function runProcess(
  command: string,
  args: string[],
  options: any,
  timeout?: number
): Promise<ExecResult> {
  return new Promise((resolve) => {
    let stdout = '';
    let stderr = '';
    let timedOut = false;
    let timeoutId: NodeJS.Timeout | null = null;

    const child = spawn(command, args, options);

    // Set up timeout (default 30s)
    const TIMEOUT_MS = timeout || 30000;
    timeoutId = setTimeout(() => {
      timedOut = true;
      // Kill entire process group if detached
      const pid = child.pid;
      if (pid && options.detached) {
        try {
          process.kill(-pid, 'SIGTERM'); // Negative PID kills the group
        } catch (e) {
          // Fallback to regular kill if group kill fails
          child.kill('SIGTERM');
        }
      } else {
        child.kill('SIGTERM');
      }
      // Grace period before SIGKILL
      setTimeout(() => {
        if (!child.killed) {
          if (pid && options.detached) {
            try {
              process.kill(-pid, 'SIGKILL');
            } catch (e) {
              child.kill('SIGKILL');
            }
          } else {
            child.kill('SIGKILL');
          }
        }
      }, 100); // 100ms grace - balance between speed and cleanup
    }, TIMEOUT_MS);

    // Capture output streams
    child.stdout?.on('data', (data) => {
      stdout += data.toString();
      // TODO: Implement size limit truncation
    });

    child.stderr?.on('data', (data) => {
      stderr += data.toString();
      // TODO: Implement size limit truncation
    });

    // Handle process completion
    child.on('close', (code, signal) => {
      if (timeoutId) {
        clearTimeout(timeoutId);
      }

      if (timedOut) {
        resolve(formatExecResult(null, stdout, stderr,
          new Error(`exec: Process timeout after ${TIMEOUT_MS / 1000}s (TIMEOUT)`)));
      } else if (code !== null) {
        resolve(formatExecResult(code, stdout, stderr));
      } else if (signal) {
        resolve(formatExecResult(null, stdout, stderr,
          new Error(`Process killed by signal ${signal}`)));
      }
    });

    // Handle spawn errors (command not found, etc)
    child.on('error', (error) => {
      if (timeoutId) {
        clearTimeout(timeoutId);
      }
      // Check if it's ENOENT (command not found)
      if ((error as any).code === 'ENOENT') {
        resolve(formatExecResult(null, stdout, stderr,
          new Error(`exec: ${command} not found in PATH (ENOENT)`)));
      } else {
        resolve(formatExecResult(null, stdout, stderr, error));
      }
    });


  });
}
=== END FILE: /Users/stuart/repos/loaf/proj/comp/exec/src/executeCommand.ts ===

=== START FILE: /Users/stuart/repos/loaf/proj/comp/orch/doc/ARCH.md ===
# Loaf Architecture


IMPORTANT TOOL TESTING NOTES:

- for test specific loaf tools, each tool must get its own test case file, for easy visibility into which tools have been implemented and tested yet.
- aka `proj/comp/fs-ops/test-data/integration/file_delete.cases.md`

## Core Design Decisions

### Transaction Model
- **No automatic rollback** - All operations commit, including failures
- **Failures are data** - LLM needs failure feedback for next steps
- **Forward-only progress** - Cheaper than regenerating responses
- **Manual rollback only** - Human-initiated via git commands
- **Boundary**: One git commit per `execute()` call
- **API**: Explicit transaction management (details TBD)

### NESL Processing Pipeline
1. NESL parser (external npm) → AST
2. AST → Action objects (nesl-ast-converter)
3. Actions → Execution → Results

### NESL AST Structure
```typescript
interface NeslParseResult {
  blocks: NeslBlock[]
  errors: NeslError[]
}

interface NeslBlock {
  id: string           // 3-char SHA-256
  properties: {
    action: string     // Maps to tool name (e.g., "file_write")
    [key: string]: any // Tool-specific parameters
  }
  startLine: number
  endLine: number
}

interface NeslError {
  code: string         // e.g., "DUPLICATE_KEY"
  line: number
  column: number
  length: number
  blockId: string
  content: string
  context: string
  message: string
}
```

### Error Propagation Strategy
- **Parser errors**: Skip blocks with parser errors, execute valid blocks only
- **Validation errors**: Skip invalid actions, execute valid ones
- **Execution errors**: Continue with remaining actions
- **Result**: Complete execution log with successes and failures

### Action Mapping
- NESL `action` property maps directly to tool names from unified-design.yaml
- Use canonical names: `file_write`, `exec`, etc.

### Context Management
- **V1**: Simple `Set<string>` of file paths
- **Storage**: In-memory only, no persistence across sessions
- **V2 Future**: Sub-file references (lines, functions, sections)

### Hooks Integration
- **Loading**: Lazy-load HooksManager on first execute() if hooks enabled
- **Config Source**: Options > loaf.yml > no hooks
- **Before Hook Failure**: Fatal - prevents NESL execution
- **After Hook Failure**: Non-fatal - recorded but doesn't affect overall success
- **Context Passing**: Minimal context to after hooks (success, counts)
- **Variable Interpolation**: Handled by hooks component, not orch

### Execution Model
- **Synchronous**: All operations block until complete
- **CWD Management**: Session-based working directory
  - Default: Repository root
  - Each exec can override with `cwd` parameter
  - CWD persists within session, not across transactions
- **Results Format**: Flat array with sequence numbers
```typescript
interface ActionResult {
  seq: number          // Execution order
  blockId: string      // NESL block ID
  action: string       // Action type
  params: any          // Input parameters
  success: boolean
  error?: string       // Error message if failed
  data?: any           // Action-specific output (stdout, content, etc.)
}
```

### Security Model (V1)
- **None**: Full filesystem access
- **No validation**: Any path allowed
- **No sandboxing**: Direct execution
- **V2 Future**: Path allowlisting per unified-design.yaml. FOR THIS REASON all fs stuff should immediately be implemented using our fs wrapper functions so this whitelisting/blacklisting is easy to implment in the future.

## Component Structure
```
loaf/
├── proj/
│   ├── comp/
│   │   ├── nesl-ast-converter/  # AST → Actions
│   │   ├── fs-ops/              # File/directory operations
│   │   ├── exec/                # Command execution
│   │   ├── git-tx/              # Git transaction management
│   │   └── context/             # Working set management
│   └── doc/
│       ├── API.md               # Main orchestrator API
│       ├── ARCH.md              # This document
│       └── ABSTRACT.md          # Project overview
```

## Implementation Priorities
1. `nesl-ast-converter` - Cannot test without this
2. `fs-ops` - Core functionality
3. `exec` - Command execution
4. `git-tx` - Transaction wrapper
5. `context` - Working set (may be simple enough to inline)

## Open Questions

### Critical
1. **NESL parser package**: `nesl-js` from `github:nesl-lang/nesl-js`
   - Import: `const { parseNESL } = require('nesl-js')`
2. **Transaction API**: Single `execute()` method processes NESL block array

### Design
1. **Parser error handling**: Execute blocks with parser errors or skip?
2. **Git conflict handling**: How to handle conflicts during manual rollback?
3. **Concurrent access**: Multiple loaf instances on same repo?
4. **Partial failure behavior**: Continue executing after first failure or abort?

### Future
1. **Context references**: Syntax for line ranges and functions
2. **Execution isolation**: Container/VM strategy for V2
3. **Streaming results**: Return results as actions complete or batch at end?

## Design Rationale

### Why No Automatic Rollback
Traditional transaction systems rollback on failure to maintain consistency. Loaf explicitly rejects this because:
1. **LLM responses are expensive** - Regenerating costs time and money
2. **Partial success is informative** - LLM learns from failures
3. **Git preserves history** - Can always manually revert
4. **Forward progress over perfection** - Incremental improvement model

### Why Synchronous Execution
1. **Deterministic results** - LLM needs to know exact outcomes
2. **Sequential dependencies** - Later actions may depend on earlier ones
3. **Simpler implementation** - No async state management
4. **Git compatibility** - Git operations are inherently synchronous

### Why In-Memory Context
1. **Session isolation** - Each LLM conversation is independent
2. **No persistence complexity** - No file format versioning
3. **Git is the source of truth** - Files on disk matter, not context
4. **Quick reset** - New session = clean slate
=== END FILE: /Users/stuart/repos/loaf/proj/comp/orch/doc/ARCH.md ===

