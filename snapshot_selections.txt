=== START FILE: /Users/stuart/repos/loaf/proj/comp/config/test/unit/validate.test.ts ===
import { describe, test, expect } from 'vitest';
import { validateConfig } from '../../src/validate.js';

describe('validateConfig', () => {
  test('accepts valid config', () => {
    const config = {
      version: 1,
      hooks: {
        before: [{ run: 'echo test' }],
        after: [{ run: 'echo done' }]
      },
      vars: {
        TEST: 'value'
      },
      'fs-guard': {
        allowed: ['./**'],
        denied: ['**/.git/**'],
        followSymlinks: false
      }
    };

    const result = validateConfig(config);
    expect(result.valid).toBe(true);
    expect(result.error).toBeUndefined();
  });

  test('rejects non-object config', () => {
    const result = validateConfig('not an object');
    expect(result.valid).toBe(false);
    expect(result.error).toBe('Config must be an object');
  });

  test('rejects missing version', () => {
    const result = validateConfig({ hooks: {} });
    expect(result.valid).toBe(false);
    expect(result.error).toBe('Config missing version');
  });

  test('rejects non-number version', () => {
    const result = validateConfig({ version: '1' });
    expect(result.valid).toBe(false);
    expect(result.error).toBe('Config version must be a number');
  });

  test('rejects non-array hooks.before', () => {
    const result = validateConfig({
      version: 1,
      hooks: { before: 'not an array' }
    });
    expect(result.valid).toBe(false);
    expect(result.error).toBe('hooks.before must be an array');
  });

  test('rejects non-array hooks.after', () => {
    const result = validateConfig({
      version: 1,
      hooks: { after: {} }
    });
    expect(result.valid).toBe(false);
    expect(result.error).toBe('hooks.after must be an array');
  });

  test('rejects non-object vars', () => {
    const result = validateConfig({
      version: 1,
      vars: []
    });
    expect(result.valid).toBe(false);
    expect(result.error).toBe('vars must be an object');
  });

  test('rejects non-string var values', () => {
    const result = validateConfig({
      version: 1,
      vars: { TEST: 123 }
    });
    expect(result.valid).toBe(false);
    expect(result.error).toBe("var 'TEST' must be a string");
  });

  test('rejects non-array fs-guard.allowed', () => {
    const result = validateConfig({
      version: 1,
      'fs-guard': { allowed: 'not an array' }
    });
    expect(result.valid).toBe(false);
    expect(result.error).toBe('fs-guard.allowed must be an array');
  });

  test('rejects non-boolean fs-guard.followSymlinks', () => {
    const result = validateConfig({
      version: 1,
      'fs-guard': { followSymlinks: 'yes' }
    });
    expect(result.valid).toBe(false);
    expect(result.error).toBe('fs-guard.followSymlinks must be a boolean');
  });

  test('accepts minimal config', () => {
    const result = validateConfig({ version: 1 });
    expect(result.valid).toBe(true);
  });

  test('accepts empty hooks', () => {
    const result = validateConfig({
      version: 1,
      hooks: {}
    });
    expect(result.valid).toBe(true);
  });
});
=== END FILE: /Users/stuart/repos/loaf/proj/comp/config/test/unit/validate.test.ts ===

=== START FILE: /Users/stuart/repos/loaf/proj/comp/orch/test/execute.test.ts ===
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { readFileSync, existsSync, rmSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';
import { marked, Token } from 'marked';
import { Loaf } from '../src/index.js';
import { clearActionSchemaCache } from '../../nesl-action-parser/src/index.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const testPath = join(__dirname, '../test-data/execute/basic-operations.md');
const mdContent = readFileSync(testPath, 'utf8');

const tokens = marked.lexer(mdContent);
const codeBlocks = tokens.filter(t => t.type === 'code') as Array<Token & { type: 'code', text: string, lang?: string }>;
const testNames = tokens
  .filter(t => t.type === 'heading' && 'depth' in t && t.depth === 3)
  .map(t => (t as any).text as string);

const testFiles = [
  '/tmp/test.txt',
  '/tmp/first.txt',
  '/tmp/second.txt',
  '/tmp/bad.txt',
  '/tmp/duplicate.txt',
  '/tmp/good.txt',
  '/tmp/does-not-exist.txt',
  '/tmp/read-test.txt',
  '/tmp/source-file.txt',
  '/tmp/destination-file.txt',
  '/tmp/replace-single.txt',
  '/tmp/replace-all.txt',
  '/tmp/multiline.txt',
  '/tmp/multiple-foo.txt',
  '/tmp/count-test.txt',
  '/tmp/move-source.txt',
  '/tmp/move-dest.txt',
  '/tmp/empty-replace.txt',
  '/tmp/parent-test.txt'
];

const testDirs = [
  '/tmp/new',
  '/tmp/007-file-move-success',
  '/tmp/016-file-move-creates-parent-dirs',
  '/tmp/017-files-read-multiple',
  '/tmp/018-files-read-with-missing'
];

describe('Loaf.execute()', () => {
  let loaf: Loaf;

  beforeEach(async () => {
    // Clear the action schema cache to pick up latest definitions
    clearActionSchemaCache();
    loaf = await Loaf.create();
    // Clean up files
    for (const path of testFiles) {
      try {
        if (existsSync(path)) rmSync(path);
      } catch (err) {
        // Continue cleanup even if one fails
      }
    }
    // Clean up directories
    for (const path of testDirs) {
      try {
        if (existsSync(path)) rmSync(path, { recursive: true, force: true });
      } catch (err) {
        // Continue cleanup even if one fails
      }
    }
  });

  afterEach(() => {
    // Clean up files
    for (const path of testFiles) {
      try {
        if (existsSync(path)) rmSync(path);
      } catch (err) {
        // Continue cleanup even if one fails
      }
    }
    // Clean up directories
    for (const path of testDirs) {
      try {
        if (existsSync(path)) rmSync(path, { recursive: true, force: true });
      } catch (err) {
        // Continue cleanup even if one fails
      }
    }
  });

  testNames.forEach((name, i) => {
    const baseIndex = i * 2;
    it(name, async () => {
      const input = codeBlocks[baseIndex].text;
      const expected = JSON.parse(codeBlocks[baseIndex + 1].text);
      const result = await loaf.execute(input);

      // Remove debug field for comparison since test data doesn't include it
      const { debug, ...resultWithoutDebug } = result;
      expect(resultWithoutDebug).toEqual(expected);
    });
  });
});
=== END FILE: /Users/stuart/repos/loaf/proj/comp/orch/test/execute.test.ts ===

