=== START FILE: /Users/stuart/repos/loaf/proj/comp/orch/src/index.ts ===
import type { LoafAction, ParseResult, ParseError } from '../../nesl-action-parser/src/index.js';
import { parseNeslResponse } from '../../nesl-action-parser/src/index.js';
import type { FileOpResult } from '../../fs-ops/src/index.js';
import type { HooksConfig, HookContext, HookResult } from '../../hooks/src/index.js';
import { HooksManager } from '../../hooks/src/index.js';
import { load as loadYaml } from 'js-yaml';
import { readFile, access } from 'fs/promises';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';
import { createStarterConfig } from './createStarterConfig.js';

export interface ExecutionResult {
  success: boolean;
  totalBlocks: number;
  executedActions: number;
  results: ActionResult[];
  parseErrors: ParseError[];
  fatalError?: string;
  hookErrors?: {
    before?: string[];
    after?: string[];
  };
  configCreated?: boolean;
  debug?: {
    parseDebug?: any;
  };
}

export interface ActionResult {
  seq: number;
  blockId: string;
  action: string;
  params: Record<string, any>;
  success: boolean;
  error?: string;
  data?: any;
}

export interface LoafOptions {
  repoPath?: string;
  gitCommit?: boolean;
  hooks?: HooksConfig;
  enableHooks?: boolean;
  createConfigIfMissing?: boolean;
}

export class Loaf {
  private options: LoafOptions;
  private executors: Map<string, (action: LoafAction) => Promise<FileOpResult>> | null = null;
  private hooksManager: HooksManager | null = null;

  constructor(options: LoafOptions = {}) {
    this.options = {
      repoPath: options.repoPath || process.cwd(),
      gitCommit: options.gitCommit ?? true,
      hooks: options.hooks,
      enableHooks: options.enableHooks ?? true,
      createConfigIfMissing: options.createConfigIfMissing ?? false
    };
  }

  /**
   * Parse and execute all NESL blocks in LLM output
   * Executes all valid actions sequentially, collecting both successes and failures
   */
  async execute(llmOutput: string): Promise<ExecutionResult> {
    const hookErrors: ExecutionResult['hookErrors'] = {};
    let configCreated = false;

    try {
      // Initialize hooks if enabled and not already initialized
      if (this.options.enableHooks && !this.hooksManager) {
        console.log('[ORCH] Initializing hooks...');
        try {
          const initResult = await this.initializeHooks();
          configCreated = initResult.configCreated || false;
          console.log('[ORCH] Hooks initialized. HooksManager exists:', !!this.hooksManager);
        } catch (error) {
          console.log('[ORCH] Hook initialization failed:', error);
          return {
            success: false,
            totalBlocks: 0,
            executedActions: 0,
            results: [],
            parseErrors: [],
            fatalError: `Failed to initialize hooks: ${error instanceof Error ? error.message : String(error)}`
          };
        }
      }

      // Run before hooks
      if (this.hooksManager) {
        console.log('[ORCH] Running before hooks...');
        try {
          const beforeResult = await this.hooksManager.runBefore();
          console.log('[ORCH] Before hooks result:', beforeResult);
          if (!beforeResult.success) {
            // Before hook failure is fatal
            return {
              success: false,
              totalBlocks: 0,
              executedActions: 0,
              results: [],
              parseErrors: [],
              hookErrors: {
                before: beforeResult.errors?.map(e => `${e.command}: ${e.error}`) || ['Unknown before hook error']
              },
              fatalError: 'Before hooks failed - aborting execution'
            };
          }
        } catch (error) {
          console.log('[ORCH] Before hooks error:', error);
          return {
            success: false,
            totalBlocks: 0,
            executedActions: 0,
            results: [],
            parseErrors: [],
            fatalError: `Before hooks threw unexpected error: ${error instanceof Error ? error.message : String(error)}`
          };
        }
      } else {
        console.log('[ORCH] No hooksManager - skipping before hooks');
      }

      // Parse NESL blocks
      const parseResult = await parseNeslResponse(llmOutput);

      // Debug info captured in parseResult.debug

      // Initialize executors if needed
      if (!this.executors) {
        try {
          await this.initializeExecutors();
        } catch (error) {
          return {
            success: false,
            totalBlocks: parseResult.summary.totalBlocks,
            executedActions: 0,
            results: [],
            parseErrors: parseResult.errors,
            fatalError: `Failed to initialize executors: ${error instanceof Error ? error.message : String(error)}`
          };
        }
      }

      // Execute each valid action sequentially
      const results: ActionResult[] = [];
      let seq = 1;

      for (const action of parseResult.actions) {
        const result = await this.executeAction(action, seq++);
        results.push(result);
      }

      // Calculate execution success (before considering after hooks)
      const allActionsSucceeded = results.every(r => r.success);
      const noParseErrors = parseResult.errors.length === 0;
      const executionSuccess = allActionsSucceeded && noParseErrors;

      // Run after hooks with context
      if (this.hooksManager) {
        try {
          // Build rich context for hooks
          const modifiedFiles = new Set<string>();
          const operations: string[] = [];
          const errors: string[] = [];
          
          for (const result of results) {
            if (result.action.startsWith('file_') && result.params.path) {
              modifiedFiles.add(result.params.path);
            }
            
            operations.push(`${result.action}${result.success ? '' : ' (failed)'}`);
            
            if (!result.success && result.error) {
              errors.push(`${result.action}: ${result.error}`);
            }
          }
          
          const afterContext: HookContext = {
            success: executionSuccess,
            executedActions: results.length,
            totalBlocks: parseResult.summary.totalBlocks,
            modifiedFiles: Array.from(modifiedFiles).join(','),
            operations: operations.join(','),
            errors: errors.join('; '),
            errorCount: errors.length
          };
          
          const afterResult = await this.hooksManager.runAfter(afterContext);
          if (!afterResult.success) {
            // After hook failure is non-fatal but recorded
            hookErrors.after = afterResult.errors?.map(e => `${e.command}: ${e.error}`) || ['Unknown after hook error'];
          }
        } catch (error) {
          // After hook unexpected errors are also non-fatal
          hookErrors.after = [`After hooks threw unexpected error: ${error instanceof Error ? error.message : String(error)}`];
        }
      }

      return {
        success: executionSuccess && !hookErrors.after, // After hook errors affect overall success
        totalBlocks: parseResult.summary.totalBlocks,
        executedActions: results.length,
        results,
        parseErrors: parseResult.errors,
        ...(Object.keys(hookErrors).length > 0 && { hookErrors }),
        ...(configCreated && { configCreated }),
        debug: {
          parseDebug: parseResult.debug
        }
      };

    } catch (error) {
      // Only truly unexpected errors should reach here
      return {
        success: false,
        totalBlocks: 0,
        executedActions: 0,
        results: [],
        parseErrors: [],
        fatalError: `Unexpected error in execute: ${error instanceof Error ? error.message : String(error)}`
      };
    }
  }

  /**
   * Initialize hooks manager with configuration
   * Loads from options or loaf.yml file
   */
  private async initializeHooks(): Promise<{ configCreated: boolean }> {
    let configCreated = false;
    
    if (this.options.hooks) {
      // Use provided configuration
      // Wrap the hooks in the expected HooksConfig structure
      const hooksConfig: HooksConfig = {
        hooks: this.options.hooks,
        vars: {}
      };
      this.hooksManager = new HooksManager(hooksConfig, this.options.repoPath);
    } else {
      // Try to load from loaf.yml
      const loafYmlPath = join(this.options.repoPath!, 'loaf.yml');
      try {
        await access(loafYmlPath);
        console.log('[ORCH] Found loaf.yml at:', loafYmlPath);
        this.hooksManager = new HooksManager(undefined, this.options.repoPath);
        const loadedConfig = await this.hooksManager.loadConfig(loafYmlPath);
        console.log('[ORCH] Loaded config:', JSON.stringify(loadedConfig, null, 2));
        // Don't create a new instance - loadConfig updates the existing one
      } catch (error: any) {
        if (error.code === 'ENOENT' && this.options.createConfigIfMissing) {
          // Create starter config
          configCreated = await createStarterConfig(this.options.repoPath!);
          if (configCreated) {
            // Load the newly created config
            this.hooksManager = new HooksManager(undefined, this.options.repoPath);
            const config = await this.hooksManager.loadConfig(loafYmlPath);
            this.hooksManager = new HooksManager(config, this.options.repoPath);
          }
        }
        // If not ENOENT or createConfigIfMissing is false, hooks remain disabled
      }
    }
    
    return { configCreated };
  }

  /**
   * Initialize action executors with dynamic imports
   * Loads routing from unified-design.yaml
   */
  private async initializeExecutors(): Promise<void> {
    this.executors = new Map();

    // Load unified-design.yaml
    const __filename = fileURLToPath(import.meta.url);
    const __dirname = dirname(__filename);
    const yamlPath = join(__dirname, '../../../../unified-design.yaml');
    const yamlContent = await readFile(yamlPath, 'utf8');
    const design = loadYaml(yamlContent) as any;

    // Map executor names to modules
    const executorModules: Record<string, () => Promise<any>> = {
      'fs-ops': () => import('../../fs-ops/src/index.js'),
      'exec': () => import('../../exec/src/index.js')
    };

    // Load executors on demand
    const loadedExecutors: Record<string, (action: LoafAction) => Promise<FileOpResult>> = {};

    // Build routing table from YAML
    for (const [actionName, actionDef] of Object.entries(design.tools)) {
      const executor = (actionDef as any).executor || this.inferExecutor(actionName, actionDef);

      if (!executor) {
        console.warn(`No executor defined for action: ${actionName}`);
        continue;
      }

      // Load executor module if not already loaded
      if (!loadedExecutors[executor]) {
        if (executorModules[executor]) {
          const module = await executorModules[executor]();
          // Handle different export names
          if (executor === 'exec') {
            loadedExecutors[executor] = module.executeCommand;
          } else {
            loadedExecutors[executor] = module.executeFileOperation || module.executeOperation;
          }
        } else {
          // Skip planned but unimplemented executors silently
          if (!['context', 'git'].includes(executor)) {
            console.warn(`Unknown executor: ${executor}`);
          }
          continue;
        }
      }

      this.executors.set(actionName, loadedExecutors[executor]);
    }
  }

  /**
   * Infer executor from action name/type when not explicitly defined
   * Temporary fallback until all YAML entries have executor field
   */
  private inferExecutor(actionName: string, actionDef: any): string | null {
    // File/dir operations go to fs-ops
    if (actionName.startsWith('file_') || actionName.startsWith('files_') ||
      actionName.startsWith('dir_') || ['ls', 'grep', 'glob'].includes(actionName)) {
      return 'fs-ops';
    }

    // Exec operations
    if (actionName === 'exec') {
      return 'exec';
    }

    // Context operations (future)
    if (actionName.startsWith('context_')) {
      return 'context';
    }

    // Git operations (future)
    if (actionName.startsWith('git_') || actionName === 'undo') {
      return 'git';
    }

    return null;
  }

  /**
   * Execute a single action and format the result
   * Never throws - all errors returned in ActionResult
   */
  private async executeAction(action: LoafAction, seq: number): Promise<ActionResult> {
    const executor = this.executors?.get(action.action);

    if (!executor) {
      return {
        seq,
        blockId: action.metadata.blockId,
        action: action.action,
        params: action.parameters,
        success: false,
        error: `Unknown action: ${action.action}`
      };
    }

    try {
      // Add default cwd for exec actions if not specified
      const enhancedAction = action.action === 'exec' && !action.parameters.cwd
        ? { ...action, parameters: { ...action.parameters, cwd: this.options.repoPath } }
        : action;

      const result = await executor(enhancedAction);

      return {
        seq,
        blockId: action.metadata.blockId,
        action: action.action,
        params: action.parameters,
        success: result.success,
        ...(result.error && { error: result.error }),
        ...(result.data !== undefined && { data: result.data }),
        // Include exec-specific fields at top level
        ...(action.action === 'exec' && {
          data: {
            stdout: result.stdout,
            stderr: result.stderr,
            exit_code: result.exit_code
          }
        })
      };

    } catch (error) {
      // Executors should never throw, but handle just in case
      return {
        seq,
        blockId: action.metadata.blockId,
        action: action.action,
        params: action.parameters,
        success: false,
        error: `Unexpected executor error: ${error instanceof Error ? error.message : String(error)}`
      };
    }
  }
}
=== END FILE: /Users/stuart/repos/loaf/proj/comp/orch/src/index.ts ===

=== START FILE: /Users/stuart/repos/loaf/proj/comp/hooks/src/index.ts ===
import { promisify } from 'util';
import { exec } from 'child_process';
import { readFile } from 'fs/promises';
import { interpolateCommand } from './interpolateCommand.js';
import { validateCommand } from './validateCommand.js';
import { formatHookResult } from './formatHookResult.js';
import { parseYamlConfig } from './parseYamlConfig.js';
import { validateConfig } from './validateConfig.js';
import type { CommandResult } from './types.js';

// Public types
export interface HooksConfig {
  version?: number;
  hooks?: {
    before?: Command[];
    after?: Command[];
  };
  vars?: Record<string, string>;
}

export interface Command {
  run: string;
  continueOnError?: boolean;
  timeout?: number;
  cwd?: string;
}

export interface HookContext {
  [key: string]: string | number | boolean;
}

export interface HookResult {
  success: boolean;
  executed: number;
  errors?: Array<{
    command: string;
    error: string;
  }>;
}

// Promisified exec
const execAsync = promisify(exec);

// Main class
export class HooksManager {
  private config: HooksConfig;
  private repoPath: string;

  constructor(config?: HooksConfig, repoPath?: string) {
    this.config = config || { hooks: {}, vars: {} };
    this.repoPath = repoPath || process.cwd();
  }

  async runBefore(context?: HookContext): Promise<HookResult> {
    const commands = this.config.hooks?.before || [];
    console.log('[HOOKS] runBefore called. Commands:', commands);
    return this.runCommands(commands, context);
  }

  async runAfter(context?: HookContext): Promise<HookResult> {
    const commands = this.config.hooks?.after || [];
    return this.runCommands(commands, context);
  }

  async loadConfig(path: string): Promise<HooksConfig> {
    try {
      const content = await readFile(path, 'utf8');
      const config = parseYamlConfig(content);
      
      const validation = validateConfig(config);
      if (!validation.valid) {
        throw new Error(`Invalid config: ${validation.error}`);
      }
      
      this.config = config;
      return config;
    } catch (error: any) {
      if (error.code === 'ENOENT') {
        throw new Error(`Config file not found: ${path}`);
      }
      throw error;
    }
  }

  private async runCommands(commands: Command[], context?: HookContext): Promise<HookResult> {
    const results: CommandResult[] = [];
    console.log('[HOOKS] runCommands called with', commands.length, 'commands');
    
    for (const cmd of commands) {
      console.log('[HOOKS] Executing command:', cmd.run);
      try {
        // Interpolate variables
        const interpolatedCmd = interpolateCommand(cmd, this.config.vars || {}, context);
        
        // Validate command
        const validation = validateCommand(interpolatedCmd);
        if (!validation.valid) {
          const result: CommandResult = {
            command: cmd.run,
            success: false,
            error: validation.error || 'Invalid command'
          };
          results.push(result);
          
          if (!cmd.continueOnError) {
            break;
          }
          continue;
        }
        
        // Execute command
        const result = await this.executeCommand(interpolatedCmd);
        console.log(`[HOOKS] Command result for "${cmd.run}":`, {
          success: result.success,
          stdout: result.stdout?.slice(0, 100),
          stderr: result.stderr?.slice(0, 100),
          error: result.error
        });
        
        // Debug: Check .hook-trace file after each command
        if (cmd.run.includes('.hook-trace')) {
          const { existsSync, readFileSync } = await import('fs');
          const tracePath = `${this.repoPath}/.hook-trace`;
          if (existsSync(tracePath)) {
            const content = readFileSync(tracePath, 'utf8');
            console.log(`[HOOKS] After "${cmd.run}", .hook-trace contains:`, JSON.stringify(content));
          } else {
            console.log(`[HOOKS] After "${cmd.run}", .hook-trace does not exist`);
          }
        }
        
        results.push({
          command: cmd.run,
          ...result
        });
        
        if (!result.success && !cmd.continueOnError) {
          break;
        }
      } catch (error: any) {
        const result: CommandResult = {
          command: cmd.run,
          success: false,
          error: error.message
        };
        results.push(result);
        
        if (!cmd.continueOnError) {
          break;
        }
      }
    }
    
    return formatHookResult(results);
  }

  private async executeCommand(cmd: Command): Promise<Omit<CommandResult, 'command'>> {
    const timeout = cmd.timeout || 30000;
    const options = {
      cwd: cmd.cwd || this.repoPath,
      timeout,
      encoding: 'utf8' as const,
      shell: true  // Ensure shell interpretation for redirects
    };
    
    try {
      const { stdout, stderr } = await execAsync(cmd.run, options);
      return {
        success: true,
        stdout: stdout || '',
        stderr: stderr || ''
      };
    } catch (error: any) {
      return {
        success: false,
        error: error.message,
        stdout: error.stdout || '',
        stderr: error.stderr || ''
      };
    }
  }
}
=== END FILE: /Users/stuart/repos/loaf/proj/comp/hooks/src/index.ts ===

=== START FILE: /Users/stuart/repos/loaf/proj/comp/hooks/test/integration/git-integration.test.ts ===
import { describe, test, expect, beforeEach, afterEach } from 'vitest';
import { existsSync, mkdirSync, rmSync, writeFileSync, readFileSync } from 'fs';
import { join } from 'path';
import { execSync } from 'child_process';
import { Loaf } from '../../../orch/src/index.js';

const TEST_BASE = '/tmp/t_hooks_git_integration';
const REPO_DIR = join(TEST_BASE, 'repo');
const REMOTE_DIR = join(TEST_BASE, 'remote.git');

describe('Git Hooks Integration', () => {
  beforeEach(() => {
    // Clean slate
    if (existsSync(TEST_BASE)) {
      rmSync(TEST_BASE, { recursive: true, force: true });
    }
    mkdirSync(TEST_BASE, { recursive: true });
    
    // Initialize bare remote
    execSync(`git init --bare ${REMOTE_DIR}`, { stdio: 'pipe' });
    
    // Initialize local repo
    mkdirSync(REPO_DIR);
    execSync('git init', { cwd: REPO_DIR, stdio: 'pipe' });
    execSync('git config user.email "test@example.com"', { cwd: REPO_DIR });
    execSync('git config user.name "Test User"', { cwd: REPO_DIR });
    execSync(`git remote add origin ${REMOTE_DIR}`, { cwd: REPO_DIR });
    
    // Initial commit (can't push empty repo)
    writeFileSync(join(REPO_DIR, 'README.md'), '# Test Repo\n');
    execSync('git add README.md', { cwd: REPO_DIR });
    execSync('git commit -m "Initial commit"', { cwd: REPO_DIR });
    execSync('git push -u origin main', { cwd: REPO_DIR });
  });

  afterEach(() => {
    if (existsSync(TEST_BASE)) {
      rmSync(TEST_BASE, { recursive: true, force: true });
    }
  });

  test('happy path - stash, modify, commit, push', async () => {
    // Setup: Create loaf.yml with git hooks
    // Use relative paths since hooks run with cwd=REPO_DIR
    const loafConfig = `version: 1
hooks:
  before:
    - run: echo "BEFORE_HOOK_RAN" > .hook-trace
    - run: git add .hook-trace
    - run: git stash push --keep-index --include-untracked
      continueOnError: true
      
  after:
    - run: echo "AFTER_HOOK_RAN" >> .hook-trace
    - run: git add -A
    - run: git commit -m "\${COMMIT_MSG}"
    - run: git push origin main

vars:
  COMMIT_MSG: "AI-assisted changes via NESL"
`;
    writeFileSync(join(REPO_DIR, 'loaf.yml'), loafConfig);
    
    // Create uncommitted changes that should be stashed
    writeFileSync(join(REPO_DIR, 'uncommitted.txt'), 'This should be stashed');
    writeFileSync(join(REPO_DIR, 'staged.txt'), 'This is staged');
    execSync('git add staged.txt', { cwd: REPO_DIR });
    
    // NESL input that creates new files
    const neslInput = `#!nesl [@three-char-SHA-256: gf1]
action = "file_write"
path = "${REPO_DIR}/generated.txt"
content = "Generated by NESL"
#!end_gf1

#!nesl [@three-char-SHA-256: gf2]
action = "file_write"  
path = "${REPO_DIR}/src/feature.js"
content = "export const feature = () => 'implemented';"
#!end_gf2`;

    // Execute with hooks - force config reload
    console.log('\n=== TEST DIAGNOSTICS ===');
    console.log('REPO_DIR:', REPO_DIR);
    console.log('loaf.yml exists:', existsSync(join(REPO_DIR, 'loaf.yml')));
    
    // Show loaf.yml content
    const loafYmlContent = readFileSync(join(REPO_DIR, 'loaf.yml'), 'utf8');
    console.log('loaf.yml content:');
    console.log(loafYmlContent);
    console.log('--- end loaf.yml ---\n');
    
    // Check if .hook-trace exists before execution
    console.log('.hook-trace exists before execution:', existsSync(join(REPO_DIR, '.hook-trace')));
    
    const loaf = new Loaf({ 
      repoPath: REPO_DIR,
      enableHooks: true,
      hooks: undefined  // Explicitly undefined to trigger loaf.yml load
    });
    
    console.log('\n=== EXECUTING NESL ===');
    const result = await loaf.execute(neslInput);
    
    // Debug: log the full result to see what's happening
    console.log('\nExecution result:', JSON.stringify(result, null, 2));
    
    // Check hook trace immediately after execution
    console.log('\n=== POST-EXECUTION DIAGNOSTICS ===');
    console.log('.hook-trace exists after execution:', existsSync(join(REPO_DIR, '.hook-trace')));
    if (existsSync(join(REPO_DIR, '.hook-trace'))) {
      const traceContent = readFileSync(join(REPO_DIR, '.hook-trace'), 'utf8');
      console.log('.hook-trace raw content:', JSON.stringify(traceContent));
      console.log('.hook-trace display:\n' + traceContent);
    }
    
    // Check git status
    console.log('\nGit status:');
    console.log(execSync('git status --porcelain', { cwd: REPO_DIR, encoding: 'utf8' }));
    
    // Check for hook errors in result
    if (result.hookErrors) {
      console.log('\nHook errors found:', result.hookErrors);
    }
    
    // Verify execution succeeded
    expect(result.success).toBe(true);
    expect(result.executedActions).toBe(2);
    expect(result.hookErrors).toBeUndefined();
    
    // Verify working directory is clean (all changes committed)
    const status = execSync('git status --porcelain', { 
      cwd: REPO_DIR, 
      encoding: 'utf8' 
    }).trim();
    expect(status).toBe('');
    
    // Verify files were created and committed
    expect(existsSync(join(REPO_DIR, 'generated.txt'))).toBe(true);
    expect(existsSync(join(REPO_DIR, 'src/feature.js'))).toBe(true);
    
    // Verify stash was created (should have our uncommitted files)
    const stashList = execSync('git stash list', { 
      cwd: REPO_DIR, 
      encoding: 'utf8' 
    });
    expect(stashList).toContain('stash@{0}');
    
    // Verify commit was made with correct message
    const lastCommit = execSync('git log -1 --pretty=%B', { 
      cwd: REPO_DIR, 
      encoding: 'utf8' 
    }).trim();
    expect(lastCommit).toBe('AI-assisted changes via NESL');
    
    // Verify push succeeded by checking remote
    const remoteLogs = execSync('git log --oneline', { 
      cwd: REMOTE_DIR, 
      encoding: 'utf8' 
    });
    expect(remoteLogs).toContain('AI-assisted changes via NESL');
    
    // Poll-based verification that remote has the files
    // (Clone to verify push worked completely)
    const cloneDir = join(TEST_BASE, 'verify-clone');
    execSync(`git clone ${REMOTE_DIR} ${cloneDir}`, { stdio: 'pipe' });
    
    let attempts = 0;
    const maxAttempts = 10;
    let filesExist = false;
    
    while (attempts < maxAttempts && !filesExist) {
      filesExist = existsSync(join(cloneDir, 'generated.txt')) && 
                   existsSync(join(cloneDir, 'src/feature.js'));
      if (!filesExist) {
        await new Promise(resolve => setTimeout(resolve, 100));
        attempts++;
      }
    }
    
    expect(filesExist).toBe(true);
    
    // Verify file contents in clone
    const generatedContent = readFileSync(join(cloneDir, 'generated.txt'), 'utf8');
    expect(generatedContent).toBe('Generated by NESL');
    
    // CRITICAL: Verify hooks actually executed
    const hookTrace = readFileSync(join(REPO_DIR, '.hook-trace'), 'utf8');
    expect(hookTrace).toContain('BEFORE_HOOK_RAN');
    expect(hookTrace).toContain('AFTER_HOOK_RAN');
    
    // Verify the specific files that were committed (not just that a commit exists)
    const commitFiles = execSync('git show --name-only --pretty="" HEAD', {
      cwd: REPO_DIR,
      encoding: 'utf8'
    }).trim().split('\n');
    expect(commitFiles).toContain('generated.txt');
    expect(commitFiles).toContain('src/feature.js');
    expect(commitFiles).not.toContain('uncommitted.txt'); // Should be in stash, not commit
  });
});
=== END FILE: /Users/stuart/repos/loaf/proj/comp/hooks/test/integration/git-integration.test.ts ===

=== START FILE: /Users/stuart/repos/loaf/proj/comp/hooks/test/integration/hooks-basic.test.ts ===
import { describe, test, expect, beforeEach, afterEach } from 'vitest';
import { mkdirSync, rmSync, readFileSync, existsSync } from 'fs';
import { join } from 'path';
import { HooksManager } from '../../src/index.js';

const TEST_DIR = '/tmp/t_hooks_test';

describe('HooksManager Integration', () => {
  beforeEach(() => {
    // Create test directory
    if (!existsSync(TEST_DIR)) {
      mkdirSync(TEST_DIR, { recursive: true });
    }
  });

  afterEach(() => {
    // Clean up test directory
    if (existsSync(TEST_DIR)) {
      rmSync(TEST_DIR, { recursive: true, force: true });
    }
  });

  test('executes before and after hooks', async () => {
    const config = {
      hooks: {
        before: [
          { run: `echo 'before' > ${TEST_DIR}/before.txt` }
        ],
        after: [
          { run: `echo 'after' > ${TEST_DIR}/after.txt` }
        ]
      }
    };

    const hooks = new HooksManager(config);
    
    // Run before hooks
    const beforeResult = await hooks.runBefore();
    expect(beforeResult.success).toBe(true);
    expect(beforeResult.executed).toBe(1);
    expect(existsSync(`${TEST_DIR}/before.txt`)).toBe(true);
    expect(readFileSync(`${TEST_DIR}/before.txt`, 'utf8').trim()).toBe('before');

    // Run after hooks
    const afterResult = await hooks.runAfter();
    expect(afterResult.success).toBe(true);
    expect(afterResult.executed).toBe(1);
    expect(existsSync(`${TEST_DIR}/after.txt`)).toBe(true);
    expect(readFileSync(`${TEST_DIR}/after.txt`, 'utf8').trim()).toBe('after');
  });

  test('variable interpolation works', async () => {
    const config = {
      hooks: {
        before: [
          { run: `echo '${TEST_DIR}/\${MSG}' > ${TEST_DIR}/var.txt` }
        ]
      },
      vars: {
        MSG: 'hello-world'
      }
    };

    const hooks = new HooksManager(config);
    const result = await hooks.runBefore();
    
    expect(result.success).toBe(true);
    expect(readFileSync(`${TEST_DIR}/var.txt`, 'utf8').trim()).toBe(`${TEST_DIR}/hello-world`);
  });

  test('context overrides vars', async () => {
    const config = {
      hooks: {
        after: [
          { run: `echo '\${STATUS}' > ${TEST_DIR}/status.txt` }
        ]
      },
      vars: {
        STATUS: 'from-config'
      }
    };

    const hooks = new HooksManager(config);
    const result = await hooks.runAfter({ STATUS: 'from-context' });
    
    expect(result.success).toBe(true);
    expect(readFileSync(`${TEST_DIR}/status.txt`, 'utf8').trim()).toBe('from-context');
  });

  test('continueOnError allows execution to continue', async () => {
    const config = {
      hooks: {
        before: [
          { run: 'false', continueOnError: true },  // Will fail
          { run: `echo 'second' > ${TEST_DIR}/second.txt` }
        ]
      }
    };

    const hooks = new HooksManager(config);
    const result = await hooks.runBefore();
    
    expect(result.success).toBe(false);
    expect(result.executed).toBe(2);
    expect(result.errors).toHaveLength(1);
    expect(existsSync(`${TEST_DIR}/second.txt`)).toBe(true);
  });

  test('stops on error without continueOnError', async () => {
    const config = {
      hooks: {
        before: [
          { run: 'false' },  // Will fail
          { run: `echo 'should not run' > ${TEST_DIR}/should-not-exist.txt` }
        ]
      }
    };

    const hooks = new HooksManager(config);
    const result = await hooks.runBefore();
    
    expect(result.success).toBe(false);
    expect(result.executed).toBe(1);
    expect(result.errors).toHaveLength(1);
    expect(existsSync(`${TEST_DIR}/should-not-exist.txt`)).toBe(false);
  });

  test('timeout kills long-running commands', async () => {
    const config = {
      hooks: {
        before: [
          { run: 'sleep 5', timeout: 100 }  // 100ms timeout
        ]
      }
    };

    const hooks = new HooksManager(config);
    const start = Date.now();
    const result = await hooks.runBefore();
    const duration = Date.now() - start;
    
    expect(result.success).toBe(false);
    expect(result.errors).toHaveLength(1);
    expect(duration).toBeLessThan(1000); // Should timeout quickly
  });

  test('loads config from YAML file', async () => {
    const yamlPath = `${TEST_DIR}/loaf.yml`;
    const yamlContent = `
version: 1
hooks:
  before:
    - run: echo 'from yaml' > ${TEST_DIR}/yaml.txt
vars:
  TEST: value
`;
    
    // Write YAML file
    const { writeFileSync } = await import('fs');
    writeFileSync(yamlPath, yamlContent);

    const hooks = new HooksManager();
    const config = await hooks.loadConfig(yamlPath);
    
    expect(config.version).toBe(1);
    expect(config.vars?.TEST).toBe('value');
    
    // Run hooks to verify they work
    const result = await hooks.runBefore();
    expect(result.success).toBe(true);
    expect(readFileSync(`${TEST_DIR}/yaml.txt`, 'utf8').trim()).toBe('from yaml');
  });

  test('custom cwd works', async () => {
    const subDir = `${TEST_DIR}/subdir`;
    mkdirSync(subDir, { recursive: true });
    
    // Use Node.js to create a cross-platform test
    // This avoids shell-specific differences
    const testScript = process.platform === 'win32' 
      ? 'node -e "require(\'fs\').writeFileSync(\'test-cwd.txt\', \'cwd-test\')"'
      : 'node -e "require(\'fs\').writeFileSync(\'test-cwd.txt\', \'cwd-test\')"';
    
    const config = {
      hooks: {
        before: [
          { run: testScript, cwd: subDir }
        ]
      }
    };

    const hooks = new HooksManager(config);
    const result = await hooks.runBefore();
    
    expect(result.success).toBe(true);
    
    // Verify the file was created in the correct directory
    const testFilePath = join(subDir, 'test-cwd.txt');
    expect(existsSync(testFilePath)).toBe(true);
    expect(readFileSync(testFilePath, 'utf8')).toBe('cwd-test');
  });
});
=== END FILE: /Users/stuart/repos/loaf/proj/comp/hooks/test/integration/hooks-basic.test.ts ===

=== START FILE: /Users/stuart/repos/loaf/proj/comp/orch/test/integration/hooks-integration.test.ts ===
import { describe, test, expect, beforeEach, afterEach } from 'vitest';
import { readFileSync, existsSync, mkdirSync, rmSync } from 'fs';
import { join } from 'path';
import { Loaf } from '../../src/index.js';
import { parseTestFile } from '../utils/parseTestFile.js';

describe('Hooks Integration', () => {
  const testDataPath = join(import.meta.dirname, '../../test-data/integration/hooks-integration.md');
  const testCases = parseTestFile(testDataPath);

  beforeEach(() => {
    // Ensure temp directories exist
    if (!existsSync('/tmp')) {
      throw new Error('Tests require /tmp directory');
    }
  });

  afterEach(() => {
    // Cleanup test directories
    const dirs = [
      '/tmp/t_hooks_integration_001',
      '/tmp/t_hooks_integration_002',
      '/tmp/t_hooks_integration_003',
      '/tmp/t_hooks_integration_004',
      '/tmp/t_hooks_integration_005'
    ];
    
    for (const dir of dirs) {
      if (existsSync(dir)) {
        rmSync(dir, { recursive: true, force: true });
      }
    }
  });

  for (const testCase of testCases) {
    test(testCase.name, async () => {
      // Setup
      if (testCase.config?.repoPath && !existsSync(testCase.config.repoPath)) {
        mkdirSync(testCase.config.repoPath, { recursive: true });
      }

      // Create Loaf instance with test config
      const loaf = new Loaf(testCase.config);

      // Execute
      const result = await loaf.execute(testCase.input);
      
      // Debug output
      console.log(`\n=== Test: ${testCase.name} ===`);
      console.log('Config:', JSON.stringify(testCase.config, null, 2));
      console.log('Result:', JSON.stringify(result, null, 2));

      // Basic assertions
      expect(result.success).toBe(testCase.expected.success);
      expect(result.totalBlocks).toBe(testCase.expected.totalBlocks);
      expect(result.executedActions).toBe(testCase.expected.executedActions);

      // Verify hook errors if expected
      if (testCase.expected.hookErrors) {
        expect(result.hookErrors).toBeDefined();
        if (testCase.expected.hookErrors.before) {
          expect(result.hookErrors?.before).toBeDefined();
          expect(result.hookErrors?.before?.length).toBeGreaterThan(0);
        }
      }

      // Verify fatal error if expected
      if (testCase.expected.fatalError) {
        expect(result.fatalError).toBe(testCase.expected.fatalError);
      }

      // Test-specific verifications
      if (testCase.verify) {
        const repoPath = testCase.config?.repoPath;
        
        if (!repoPath) {
          throw new Error(`Test ${testCase.name} has verify=true but no repoPath in config`);
        }
        
        switch (testCase.name) {
          case '001-basic-hooks-execution': {
            const tracePath = join(repoPath, 'hook-trace.txt');
            expect(existsSync(tracePath)).toBe(true);
            const trace = readFileSync(tracePath, 'utf8');
            expect(trace).toContain('BEFORE_RAN');
            expect(trace).toContain('AFTER_RAN');
            expect(trace).toContain('FILES_MODIFIED=');
            break;
          }
          
          case '002-hooks-with-failures': {
            const resultPath = join(repoPath, 'result.txt');
            expect(existsSync(resultPath)).toBe(true);
            const content = readFileSync(resultPath, 'utf8');
            expect(content).toContain('SUCCESS=false');
            expect(content).toContain('ERRORS=1');
            break;
          }
          
          case '003-before-hook-failure-aborts': {
            const testPath = join(repoPath, 'test.txt');
            const afterPath = join(repoPath, 'after.txt');
            expect(existsSync(testPath)).toBe(false);
            expect(existsSync(afterPath)).toBe(false);
            break;
          }
          
          case '004-context-variables-in-hooks': {
            const summaryPath = join(repoPath, 'summary.txt');
            expect(existsSync(summaryPath)).toBe(true);
            const summary = readFileSync(summaryPath, 'utf8');
            expect(summary).toContain('Total blocks: 2');
            expect(summary).toContain('Executed: 2');
            expect(summary).toContain('Operations: file_write,file_read');
            break;
          }
          
          case '005-loaf-yml-auto-creation': {
            const configPath = join(repoPath, 'loaf.yml');
            expect(existsSync(configPath)).toBe(true);
            const testPath = join(repoPath, 'test.txt');
            expect(existsSync(testPath)).toBe(true);
            break;
          }
        }
      }
    });
  }
});
=== END FILE: /Users/stuart/repos/loaf/proj/comp/orch/test/integration/hooks-integration.test.ts ===

=== START FILE: /Users/stuart/repos/loaf/proj/comp/hooks/src/types.ts ===
// Re-export public types from index
export type { HooksConfig, Command, HookContext, HookResult } from './index.js';

// Internal types
export interface CommandResult {
  command: string;
  success: boolean;
  error?: string;
  stdout?: string;
  stderr?: string;
}

export interface ValidationResult {
  valid: boolean;
  error?: string;
}
=== END FILE: /Users/stuart/repos/loaf/proj/comp/hooks/src/types.ts ===

=== START FILE: /Users/stuart/repos/loaf/proj/comp/hooks/test-data/integration/example-loaf.yml ===
# Example loaf.yml configuration
version: 1

hooks:
  before:
    - run: git stash --include-untracked
      
  after:
    - run: git add -A
    - run: git commit -m "${COMMIT_MSG}"
    - run: git push
      continueOnError: true
      timeout: 10000  # 10s for slow networks

# Variables available in commands
vars:
  COMMIT_MSG: "AI-assisted changes"
  BRANCH: "main"
  REMOTE: "origin"
=== END FILE: /Users/stuart/repos/loaf/proj/comp/hooks/test-data/integration/example-loaf.yml ===

=== START FILE: /Users/stuart/repos/loaf/use-listener/instruct.md ===
# NESL Tool API Reference

## NESL Syntax example 


```sh nesl
#!nesl [@three-char-SHA-256: q8r]
action = "tool_name"
param1 = <<'EOT_q8r'
value line 1

 value line 2
EOT_q8r
param2 = "value"
#!end_q8r
```

equivalent json:

```json
{
 "action": "tool_name",
 "param1": "value line 1\n\n value line 2",
 "param2": "value"
}
```

**Critical constraints:**
- Paths: always absolute
- Whitespace: preserved exactly in heredocs

## Tools

### `file_write` - Create/overwrite file
```sh
#!nesl [@three-char-SHA-256: fw1]
action = "file_write"
path = "/home/user/script.py"
content = <<'EOT_fw1'
#!/usr/bin/env python3
print("Hello")
EOT_fw1
#!end_fw1
```

### `file_replace_text` - Replace one occurrence
```sh
#!nesl [@three-char-SHA-256: fr2]
action = "file_replace_text"
path = "/etc/config.ini"
old_text = <<'EOT_fr2'
debug = false
EOT_fr2
new_text = <<'EOT_fr2'
debug = true
EOT_fr2
#!end_fr2
```

### `file_read` - Read single file
```sh
#!nesl [@three-char-SHA-256: rd3]
action = "file_read"
path = "/var/log/app.log"
#!end_rd3
```

### `files_read` - Read multiple files
```sh
#!nesl [@three-char-SHA-256: rm4]
action = "files_read"
paths = <<'EOT_rm4'
/tmp/file1.txt
/tmp/file2.txt
/usr/local/bin/script.sh
EOT_rm4
#!end_rm4
```
=== END FILE: /Users/stuart/repos/loaf/use-listener/instruct.md ===

=== START FILE: /Users/stuart/repos/loaf/xd5_ref.md ===
# XD5 LLM Quick Reference

## Core Principle
Documentation maintains dependency graphs for deterministic context assembly. Initial dependencies are hypotheses - implementation discovers reality. The STOP protocol ensures documentation evolves to match actual dependencies.

## File Structure
```
<repo>/
â””â”€â”€ proj/
    â”œâ”€â”€ doc/
    â”‚   â”œâ”€â”€ API.md        # âš ï¸ CRITICAL: All dependencies + exports
    â”‚   â”œâ”€â”€ ABSTRACT.md   # 60-word purpose + 300-word overview + brief spec in EARS format (The Easy Approach to Requirements Syntax)
    â”‚   â””â”€â”€ ARCH.md       # Technical decisions, constraints
    â”œâ”€â”€ test-data/        # Test cases as JSON/MD files
    â”‚   â”œâ”€â”€ unit/         # Unit test data
    â”‚   â””â”€â”€ integration/  # Integration test data
    â”œâ”€â”€ test/             # Minimal harnesses loading test-data
    â”‚   â”œâ”€â”€ unit/         # Unit test harnesses
    â”‚   â””â”€â”€ integration/  # Integration test harnesses
    â”œâ”€â”€ test-intn/        # Integration tests for dependencies
    â”œâ”€â”€ src/              # Implementation
    â””â”€â”€ comp/             # Sub-components (recursive) - do not need 'proj' dirs
```

## API.md Template
```markdown
# Component: {name}

## Component Type
standard | types-only

## Dependencies
[Provisional - updated via STOP protocol when implementation reveals actual needs]

Mark internal component status: [PLANNED], [IN-PROGRESS], or [IMPLEMENTED]
External dependencies do not need status markers.

```yaml
dependencies:
  # Initial hypothesis based on design
  proj/comp/payment:                                       # [PLANNED]
    functions: [validateCard, processRefund] # may change 
    types: [PaymentResult, CardType]
    errors: [PaymentError]
  
  proj/comp/auth:                                          # [IMPLEMENTED]
    functions: [checkPermission, validateToken]
    types: [User, TokenPayload]
  
  proj/comp/logger:                                        # [IN-PROGRESS]
    functions: [logTransaction]  # Audit requirement
  
  proj/comp/payment-types: "*"  # Wildcard for types-only  # [IMPLEMENTED] 
  
  external/lodash:
    functions: [groupBy, mapValues]
  
  external/@stripe/stripe-js:
    types: [Stripe, PaymentIntent]
    functions: [loadStripe]
```

## Exports
[Structured YAML for dependency graph tooling, then prose descriptions]

```yaml
exports:
  functions: [functionName1, functionName2]
  types: [Type1, Type2, Type3]
  classes:
    ClassName:
      methods: [method1, method2]
  errors: [CustomError1, CustomError2]
```

### {functionName}
- **Signature**: `{functionName}(param: Type) -> ReturnType`
- **Purpose**: Single sentence.
- **Throws**: `{ErrorType}` when {condition}
- **Test-data**: `test-data/{path}/{functionName}.json` [PLANNED|IMPLEMENTED]



## Workflow

### Core Flow: Design â†’ Test â†’ Implement

1. **Write docs**: ABSTRACT.md â†’ ARCH.md â†’ API.md (provisional)
2. **Design tests**: E2E hypothesis â†’ Decompose â†’ Unit tests  
3. **Implement**: Discover real dependencies â†’ Update docs â†’ Complete code

### Test Authority & Evolution

**Tests Are Source of Truth (But Not Infallible)**
- Tests define what code SHOULD do
- During debug: ALWAYS fix code to match tests first
- Test errors discovered? Ask human: "I believe test X is incorrect because Y. Should I update it?"
- NEVER auto-modify tests while debugging
- Each test change needs explicit approval

### Detailed Flow

1. **E2E Test Hypothesis** - Write component test-data (expect evolution)
2. **Pseudocode** - Rough implementation to discover structure
3. **Extract Functions** - Identify & extract all pure functions
4. **Unit Tests** - Write test-data for each function
5. **Implement Functions** - Red/green/debug (fix code, not tests)
6. **Revise E2E Tests** - Align with discovered behavior (ask human)
7. **Wire Component** - Connect tested functions
8. **Debug E2E** - Fix code until green

**Debug Protocol**: Test fails? â†’ Try fixing code â†’ Still failing? â†’ Consider test error â†’ Request human approval for any test change

**If docs are wrong**: STOP â†’ Update docs â†’ Update tests â†’ Continue



### Critical Implementation Rules

**Initial Docs Are Hypotheses**: 
- First API.md contains best guesses
- Dependencies WILL be wrong
- This is expected and healthy
- Discovery through implementation is the goal

**ðŸ›‘ STOP Protocol**: When implementation reveals doc errors:
1. STOP immediately
2. Update API.md/ARCH.md
3. Continue with correct docs

**Test Immutability**: 
- Test harnesses = frozen after creation
- Test data = only change with human approval
- Fix code, not tests (unless explicitly approved)

**Dependency Updates**:
- Add to API.md as discovered
- Include transitive deps if needed for understanding
- External deps must be explicit

## Test Data Format
```json
{
  "cases": [
    {
      "name": "descriptive name",
      "input": [arg1, arg2],
      "expected": {result},
      "throws": "ErrorType"  // optional
    }
  ]
}
```

## Quick Checks

Before implementing:
- [ ] API.md declares all exports?
- [ ] Dependencies section updated?
- [ ] Test data files created?

During implementation:
- [ ] Tests fail first (red phase)?
- [ ] Docs match reality? (if not â†’ STOP)
- [ ] All imports declared in API.md?

## Common Patterns

**Extract pure functions during pseudocode**:
```javascript
// Pseudocode reveals:
// extractedFn: validateInput(x) -> bool
// extractedFn: processData(data) -> result
```

**Types-only components**: No test/ or src/, only doc/

**Path conventions**: All relative to `<repo>/`
- Component: `proj/comp/{name}`
- Nested: `proj/comp/{parent}/comp/{child}`


# update 

- need to update this so that we save our pseudocde in some sort of documetnation, maybe temp documentation.  so if we implement the fucntiosn to unit test, we dont get confused later about how theyre supposed to be used.

- ideally, each extracted function unit-testable function would be in its own file.  for parallelism with the unit test files

- TESTING PATHS

dont save files directly to `/tmp/`.  save them to a dir in the tmp dir taht is named with the name of the test preceedd by 't_', eg `/tmp/t_move-nonexistent-file`

like: 


### 003-move-nonexistent-file

```sh nesl
#!nesl [@three-char-SHA-256: mnf]
action = "file_move"
old_path = "/tmp/t_move-nonexistent-file/ghost.txt"
new_path = "/tmp/t_move-nonexistent-file/nowhere.txt"
#!end_mnf
```

```json
{
  "success": false,
  "error": "file_move: Source file not found '/tmp/t_move-nonexistent-file/ghost.txt' (ENOENT)"
}
```



consider using EARS somehow for specs/reqs: EARS: The Easy Approach to Requirements Syntax

for dependency blocks in docs api, do not include external dependencies!!
=== END FILE: /Users/stuart/repos/loaf/xd5_ref.md ===

