=== START FILE: /Users/stuart/repos/loaf/proj/comp/orch/src/createStarterConfig.ts ===
import { writeFile } from 'fs/promises';
import { join } from 'path';

const STARTER_LOAF_YML = `# Loaf configuration
version: 1

hooks:
  # Uncomment and modify these examples as needed
  
  # before:
  #   - run: git stash --include-untracked
  #     continueOnError: false
  
  # after:
  #   - run: git add -A
  #   - run: git commit -m "\${COMMIT_MSG}"
  #     continueOnError: false
  #   - run: git push
  #     continueOnError: true
  #     timeout: 10000  # 10s for slow networks

# Variables available in commands
vars:
  COMMIT_MSG: "AI-assisted changes"
  # Add more variables as needed
`;

/**
 * Creates a starter loaf.yml file if it doesn't exist
 * @returns true if file was created, false if already exists
 */
export async function createStarterConfig(repoPath: string): Promise<boolean> {
  const configPath = join(repoPath, 'loaf.yml');
  
  try {
    await writeFile(configPath, STARTER_LOAF_YML, { flag: 'wx' });
    return true;
  } catch (error: any) {
    if (error.code === 'EEXIST') {
      return false;
    }
    throw error;
  }
}
=== END FILE: /Users/stuart/repos/loaf/proj/comp/orch/src/createStarterConfig.ts ===

=== START FILE: /Users/stuart/repos/loaf/proj/comp/orch/src/index.ts ===
import type { LoafAction, ParseResult, ParseError } from '../../nesl-action-parser/src/index.js';
import { parseNeslResponse } from '../../nesl-action-parser/src/index.js';
import type { FileOpResult } from '../../fs-ops/src/index.js';
import type { HooksConfig, HookContext, HookResult } from '../../hooks/src/index.js';
import { HooksManager } from '../../hooks/src/index.js';
import { load as loadYaml } from 'js-yaml';
import { readFile, access } from 'fs/promises';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';

export interface ExecutionResult {
  success: boolean;
  totalBlocks: number;
  executedActions: number;
  results: ActionResult[];
  parseErrors: ParseError[];
  fatalError?: string;
  hookErrors?: {
    before?: string[];
    after?: string[];
  };
  debug?: {
    parseDebug?: any;
  };
}

export interface ActionResult {
  seq: number;
  blockId: string;
  action: string;
  params: Record<string, any>;
  success: boolean;
  error?: string;
  data?: any;
}

export interface LoafOptions {
  repoPath?: string;
  gitCommit?: boolean;
  hooks?: HooksConfig;
  enableHooks?: boolean;
}

export class Loaf {
  private options: LoafOptions;
  private executors: Map<string, (action: LoafAction) => Promise<FileOpResult>> | null = null;
  private hooksManager: HooksManager | null = null;

  constructor(options: LoafOptions = {}) {
    this.options = {
      repoPath: options.repoPath || process.cwd(),
      gitCommit: options.gitCommit ?? true,
      hooks: options.hooks,
      enableHooks: options.enableHooks ?? true
    };
  }

  /**
   * Parse and execute all NESL blocks in LLM output
   * Executes all valid actions sequentially, collecting both successes and failures
   */
  async execute(llmOutput: string): Promise<ExecutionResult> {
    const hookErrors: ExecutionResult['hookErrors'] = {};

    try {
      // Initialize hooks if enabled and not already initialized
      if (this.options.enableHooks && !this.hooksManager) {
        try {
          await this.initializeHooks();
        } catch (error) {
          return {
            success: false,
            totalBlocks: 0,
            executedActions: 0,
            results: [],
            parseErrors: [],
            fatalError: `Failed to initialize hooks: ${error instanceof Error ? error.message : String(error)}`
          };
        }
      }

      // Run before hooks
      if (this.hooksManager) {
        try {
          const beforeResult = await this.hooksManager.runBefore();
          if (!beforeResult.success) {
            // Before hook failure is fatal
            return {
              success: false,
              totalBlocks: 0,
              executedActions: 0,
              results: [],
              parseErrors: [],
              hookErrors: {
                before: beforeResult.errors?.map(e => `${e.command}: ${e.error}`) || ['Unknown before hook error']
              },
              fatalError: 'Before hooks failed - aborting execution'
            };
          }
        } catch (error) {
          return {
            success: false,
            totalBlocks: 0,
            executedActions: 0,
            results: [],
            parseErrors: [],
            fatalError: `Before hooks threw unexpected error: ${error instanceof Error ? error.message : String(error)}`
          };
        }
      }

      // Parse NESL blocks
      const parseResult = await parseNeslResponse(llmOutput);

      // Debug info captured in parseResult.debug

      // Initialize executors if needed
      if (!this.executors) {
        try {
          await this.initializeExecutors();
        } catch (error) {
          return {
            success: false,
            totalBlocks: parseResult.summary.totalBlocks,
            executedActions: 0,
            results: [],
            parseErrors: parseResult.errors,
            fatalError: `Failed to initialize executors: ${error instanceof Error ? error.message : String(error)}`
          };
        }
      }

      // Execute each valid action sequentially
      const results: ActionResult[] = [];
      let seq = 1;

      for (const action of parseResult.actions) {
        const result = await this.executeAction(action, seq++);
        results.push(result);
      }

      // Calculate execution success (before considering after hooks)
      const allActionsSucceeded = results.every(r => r.success);
      const noParseErrors = parseResult.errors.length === 0;
      const executionSuccess = allActionsSucceeded && noParseErrors;

      // Run after hooks with context
      if (this.hooksManager) {
        try {
          // Build rich context for hooks
          const modifiedFiles = new Set<string>();
          const operations: string[] = [];
          const errors: string[] = [];
          
          for (const result of results) {
            if (result.action.startsWith('file_') && result.params.path) {
              modifiedFiles.add(result.params.path);
            }
            
            operations.push(`${result.action}${result.success ? '' : ' (failed)'}`);
            
            if (!result.success && result.error) {
              errors.push(`${result.action}: ${result.error}`);
            }
          }
          
          const afterContext: HookContext = {
            success: executionSuccess,
            executedActions: results.length,
            totalBlocks: parseResult.summary.totalBlocks,
            modifiedFiles: Array.from(modifiedFiles).join(','),
            operations: operations.join(','),
            errors: errors.join('; '),
            errorCount: errors.length
          };
          
          const afterResult = await this.hooksManager.runAfter(afterContext);
          if (!afterResult.success) {
            // After hook failure is non-fatal but recorded
            hookErrors.after = afterResult.errors?.map(e => `${e.command}: ${e.error}`) || ['Unknown after hook error'];
          }
        } catch (error) {
          // After hook unexpected errors are also non-fatal
          hookErrors.after = [`After hooks threw unexpected error: ${error instanceof Error ? error.message : String(error)}`];
        }
      }

      return {
        success: executionSuccess && !hookErrors.after, // After hook errors affect overall success
        totalBlocks: parseResult.summary.totalBlocks,
        executedActions: results.length,
        results,
        parseErrors: parseResult.errors,
        ...(Object.keys(hookErrors).length > 0 && { hookErrors }),
        debug: {
          parseDebug: parseResult.debug
        }
      };

    } catch (error) {
      // Only truly unexpected errors should reach here
      return {
        success: false,
        totalBlocks: 0,
        executedActions: 0,
        results: [],
        parseErrors: [],
        fatalError: `Unexpected error in execute: ${error instanceof Error ? error.message : String(error)}`
      };
    }
  }

  /**
   * Initialize hooks manager with configuration
   * Loads from options or loaf.yml file
   */
  private async initializeHooks(): Promise<void> {
    if (this.options.hooks) {
      // Use provided configuration
      this.hooksManager = new HooksManager(this.options.hooks, this.options.repoPath);
    } else {
      // Try to load from loaf.yml
      const loafYmlPath = join(this.options.repoPath!, 'loaf.yml');
      try {
        await access(loafYmlPath);
        this.hooksManager = new HooksManager(undefined, this.options.repoPath);
        const config = await this.hooksManager.loadConfig(loafYmlPath);
        this.hooksManager = new HooksManager(config, this.options.repoPath);
      } catch (error) {
        // No loaf.yml found, hooks will be disabled
        // This is not an error - hooks are optional
      }
    }
  }

  /**
   * Initialize action executors with dynamic imports
   * Loads routing from unified-design.yaml
   */
  private async initializeExecutors(): Promise<void> {
    this.executors = new Map();

    // Load unified-design.yaml
    const __filename = fileURLToPath(import.meta.url);
    const __dirname = dirname(__filename);
    const yamlPath = join(__dirname, '../../../../unified-design.yaml');
    const yamlContent = await readFile(yamlPath, 'utf8');
    const design = loadYaml(yamlContent) as any;

    // Map executor names to modules
    const executorModules: Record<string, () => Promise<any>> = {
      'fs-ops': () => import('../../fs-ops/src/index.js'),
      'exec': () => import('../../exec/src/index.js')
    };

    // Load executors on demand
    const loadedExecutors: Record<string, (action: LoafAction) => Promise<FileOpResult>> = {};

    // Build routing table from YAML
    for (const [actionName, actionDef] of Object.entries(design.tools)) {
      const executor = (actionDef as any).executor || this.inferExecutor(actionName, actionDef);

      if (!executor) {
        console.warn(`No executor defined for action: ${actionName}`);
        continue;
      }

      // Load executor module if not already loaded
      if (!loadedExecutors[executor]) {
        if (executorModules[executor]) {
          const module = await executorModules[executor]();
          // Handle different export names
          if (executor === 'exec') {
            loadedExecutors[executor] = module.executeCommand;
          } else {
            loadedExecutors[executor] = module.executeFileOperation || module.executeOperation;
          }
        } else {
          // Skip planned but unimplemented executors silently
          if (!['context', 'git'].includes(executor)) {
            console.warn(`Unknown executor: ${executor}`);
          }
          continue;
        }
      }

      this.executors.set(actionName, loadedExecutors[executor]);
    }
  }

  /**
   * Infer executor from action name/type when not explicitly defined
   * Temporary fallback until all YAML entries have executor field
   */
  private inferExecutor(actionName: string, actionDef: any): string | null {
    // File/dir operations go to fs-ops
    if (actionName.startsWith('file_') || actionName.startsWith('files_') ||
      actionName.startsWith('dir_') || ['ls', 'grep', 'glob'].includes(actionName)) {
      return 'fs-ops';
    }

    // Exec operations
    if (actionName === 'exec') {
      return 'exec';
    }

    // Context operations (future)
    if (actionName.startsWith('context_')) {
      return 'context';
    }

    // Git operations (future)
    if (actionName.startsWith('git_') || actionName === 'undo') {
      return 'git';
    }

    return null;
  }

  /**
   * Execute a single action and format the result
   * Never throws - all errors returned in ActionResult
   */
  private async executeAction(action: LoafAction, seq: number): Promise<ActionResult> {
    const executor = this.executors?.get(action.action);

    if (!executor) {
      return {
        seq,
        blockId: action.metadata.blockId,
        action: action.action,
        params: action.parameters,
        success: false,
        error: `Unknown action: ${action.action}`
      };
    }

    try {
      // Add default cwd for exec actions if not specified
      const enhancedAction = action.action === 'exec' && !action.parameters.cwd
        ? { ...action, parameters: { ...action.parameters, cwd: this.options.repoPath } }
        : action;

      const result = await executor(enhancedAction);

      return {
        seq,
        blockId: action.metadata.blockId,
        action: action.action,
        params: action.parameters,
        success: result.success,
        ...(result.error && { error: result.error }),
        ...(result.data !== undefined && { data: result.data }),
        // Include exec-specific fields at top level
        ...(action.action === 'exec' && {
          data: {
            stdout: result.stdout,
            stderr: result.stderr,
            exit_code: result.exit_code
          }
        })
      };

    } catch (error) {
      // Executors should never throw, but handle just in case
      return {
        seq,
        blockId: action.metadata.blockId,
        action: action.action,
        params: action.parameters,
        success: false,
        error: `Unexpected executor error: ${error instanceof Error ? error.message : String(error)}`
      };
    }
  }
}
=== END FILE: /Users/stuart/repos/loaf/proj/comp/orch/src/index.ts ===

=== START FILE: /Users/stuart/repos/loaf/proj/comp/orch/test/integration/hooks-integration.test.ts ===
import { describe, test, expect, beforeEach, afterEach } from 'vitest';
import { readFileSync, existsSync, mkdirSync, rmSync } from 'fs';
import { join } from 'path';
import { Loaf } from '../../src/index.js';
import { parseTestFile } from '../utils/parseTestFile.js';

describe('Hooks Integration', () => {
  const testDataPath = join(import.meta.dirname, '../../test-data/integration/hooks-integration.md');
  const testCases = parseTestFile(testDataPath);

  beforeEach(() => {
    // Ensure temp directories exist
    if (!existsSync('/tmp')) {
      throw new Error('Tests require /tmp directory');
    }
  });

  afterEach(() => {
    // Cleanup test directories
    const dirs = [
      '/tmp/t_hooks_integration_001',
      '/tmp/t_hooks_integration_002',
      '/tmp/t_hooks_integration_003',
      '/tmp/t_hooks_integration_004',
      '/tmp/t_hooks_integration_005'
    ];
    
    for (const dir of dirs) {
      if (existsSync(dir)) {
        rmSync(dir, { recursive: true, force: true });
      }
    }
  });

  for (const testCase of testCases) {
    test(testCase.name, async () => {
      // Setup
      if (testCase.config?.repoPath && !existsSync(testCase.config.repoPath)) {
        mkdirSync(testCase.config.repoPath, { recursive: true });
      }

      // Create Loaf instance with test config
      const loaf = new Loaf(testCase.config);

      // Execute
      const result = await loaf.execute(testCase.input);
      
      // Debug output
      console.log(`\n=== Test: ${testCase.name} ===`);
      console.log('Result:', JSON.stringify(result, null, 2));

      // Basic assertions
      expect(result.success).toBe(testCase.expected.success);
      expect(result.totalBlocks).toBe(testCase.expected.totalBlocks);
      expect(result.executedActions).toBe(testCase.expected.executedActions);

      // Verify hook errors if expected
      if (testCase.expected.hookErrors) {
        expect(result.hookErrors).toBeDefined();
        if (testCase.expected.hookErrors.before) {
          expect(result.hookErrors?.before).toBeDefined();
          expect(result.hookErrors?.before?.length).toBeGreaterThan(0);
        }
      }

      // Verify fatal error if expected
      if (testCase.expected.fatalError) {
        expect(result.fatalError).toBe(testCase.expected.fatalError);
      }

      // Test-specific verifications
      if (testCase.verify) {
        const repoPath = testCase.config.repoPath;
        
        switch (testCase.name) {
          case '001-basic-hooks-execution': {
            const tracePath = join(repoPath, 'hook-trace.txt');
            expect(existsSync(tracePath)).toBe(true);
            const trace = readFileSync(tracePath, 'utf8');
            expect(trace).toContain('BEFORE_RAN');
            expect(trace).toContain('AFTER_RAN');
            expect(trace).toContain('FILES_MODIFIED=');
            break;
          }
          
          case '002-hooks-with-failures': {
            const resultPath = join(repoPath, 'result.txt');
            expect(existsSync(resultPath)).toBe(true);
            const content = readFileSync(resultPath, 'utf8');
            expect(content).toContain('SUCCESS=false');
            expect(content).toContain('ERRORS=1');
            break;
          }
          
          case '003-before-hook-failure-aborts': {
            const testPath = join(repoPath, 'test.txt');
            const afterPath = join(repoPath, 'after.txt');
            expect(existsSync(testPath)).toBe(false);
            expect(existsSync(afterPath)).toBe(false);
            break;
          }
          
          case '004-context-variables-in-hooks': {
            const summaryPath = join(repoPath, 'summary.txt');
            expect(existsSync(summaryPath)).toBe(true);
            const summary = readFileSync(summaryPath, 'utf8');
            expect(summary).toContain('Total blocks: 2');
            expect(summary).toContain('Executed: 2');
            expect(summary).toContain('Operations: file_write,file_read');
            break;
          }
          
          case '005-loaf-yml-auto-creation': {
            const configPath = join(repoPath, 'loaf.yml');
            expect(existsSync(configPath)).toBe(true);
            const testPath = join(repoPath, 'test.txt');
            expect(existsSync(testPath)).toBe(true);
            break;
          }
        }
      }
    });
  }
});
=== END FILE: /Users/stuart/repos/loaf/proj/comp/orch/test/integration/hooks-integration.test.ts ===

=== START FILE: /Users/stuart/repos/loaf/proj/comp/orch/test/utils/parseTestFile.ts ===
import { readFileSync } from 'fs';
import { load as loadYaml } from 'js-yaml';

export interface TestCase {
  name: string;
  config: any;
  input: string;
  expected: any;
  verify?: boolean;
}

/**
 * Parse test cases from markdown file containing:
 * - Test name as ## heading
 * - YAML config block
 * - NESL input block
 * - JSON expected output block
 */
export function parseTestFile(filepath: string): TestCase[] {
  const content = readFileSync(filepath, 'utf8');
  const testCases: TestCase[] = [];
  
  // Split by test case headers (## XXX-name)
  const sections = content.split(/^## /m).slice(1); // Skip content before first ##
  
  for (const section of sections) {
    const lines = section.split('\n');
    const name = lines[0].trim();
    
    let config: any = {};
    let input = '';
    let expected: any = {};
    let verify = false;
    
    let currentBlock = '';
    let blockType = '';
    let inCodeBlock = false;
    
    for (let i = 1; i < lines.length; i++) {
      const line = lines[i];
      
      // Check for code block markers
      if (line.startsWith('```')) {
        if (!inCodeBlock) {
          inCodeBlock = true;
          blockType = line.slice(3).trim();
          currentBlock = '';
        } else {
          // End of code block - process it
          inCodeBlock = false;
          
          if (blockType === 'yaml') {
            config = loadYaml(currentBlock);
          } else if (blockType === 'sh nesl') {
            input = currentBlock;
          } else if (blockType === 'json') {
            try {
              expected = JSON.parse(currentBlock);
            } catch (e) {
              console.error(`Failed to parse JSON for test case "${name}":`);
              console.error(`JSON content:\n${currentBlock}`);
              console.error(`Error: ${e}`);
              throw e;
            }
          }
          
          blockType = '';
        }
      } else if (inCodeBlock) {
        currentBlock += line + '\n';
      } else if (line.startsWith('Verify:')) {
        verify = true;
      }
    }
    
    // Trim trailing newline from input
    input = input.trimEnd();
    
    testCases.push({
      name,
      config,
      input,
      expected,
      verify
    });
  }
  
  return testCases;
}
=== END FILE: /Users/stuart/repos/loaf/proj/comp/orch/test/utils/parseTestFile.ts ===

=== START FILE: /Users/stuart/repos/loaf/proj/comp/orch/test-data/integration/hooks-integration.md ===
# Hooks Integration Test Cases

## 001-basic-hooks-execution

Tests that before and after hooks execute correctly around NESL operations.

```yaml
config:
  repoPath: /tmp/t_hooks_integration_001
  hooks:
    hooks:
      before:
        - run: echo 'BEFORE_RAN' > hook-trace.txt
      after:
        - run: echo 'AFTER_RAN' >> hook-trace.txt
        - run: echo 'FILES_MODIFIED=${modifiedFiles}' >> hook-trace.txt
```

```sh nesl
#!nesl [@three-char-SHA-256: bhe]
action = "file_write"
path = "/tmp/t_hooks_integration_001/test.txt"
content = "Hello from NESL"
#!end_bhe
```

```json
{
  "success": true,
  "totalBlocks": 1,
  "executedActions": 1,
  "results": [
    {
      "seq": 1,
      "blockId": "bhe",
      "action": "file_write",
      "params": {
        "path": "test.txt",
        "content": "Hello from NESL"
      },
      "success": true
    }
  ],
  "parseErrors": []
}
```

Verify:
- hook-trace.txt contains "BEFORE_RAN\nAFTER_RAN\nFILES_MODIFIED=test.txt"

## 002-hooks-with-failures

Tests hook behavior when NESL operations fail.

```yaml
config:
  repoPath: /tmp/t_hooks_integration_002
  hooks:
    hooks:
      before:
        - run: mkdir -p nested/dir
      after:
        - run: echo 'SUCCESS=${success}' > result.txt
        - run: echo 'ERRORS=${errorCount}' >> result.txt
```

```sh nesl
#!nesl [@three-char-SHA-256: hwf]
action = "file_write"
path = "/invalid\0path/test.txt"
content = "This will fail"
#!end_hwf
```

```json
{
  "success": false,
  "totalBlocks": 1,
  "executedActions": 1,
  "results": [
    {
      "seq": 1,
      "blockId": "hwf",
      "action": "file_write",
      "params": {
        "path": "/invalid\\0path/test.txt",
        "content": "This will fail"
      },
      "success": false,
      "error": "Invalid path: contains null character"
    }
  ],
  "parseErrors": []
}
```

Verify:
- result.txt contains "SUCCESS=false\nERRORS=1"

## 003-before-hook-failure-aborts

Tests that before hook failures prevent NESL execution.

```yaml
config:
  repoPath: /tmp/t_hooks_integration_003
  hooks:
    hooks:
      before:
        - run: "false"  # Always fails
      after:
        - run: echo 'SHOULD_NOT_RUN' > after.txt
```

```sh nesl
#!nesl [@three-char-SHA-256: bhf]
action = "file_write"
path = "/tmp/t_hooks_integration_003/test.txt"
content = "Should not be written"
#!end_bhf
```

```json
{
  "success": false,
  "totalBlocks": 0,
  "executedActions": 0,
  "results": [],
  "parseErrors": [],
  "hookErrors": {
    "before": ["false: Command failed with exit code 1"]
  },
  "fatalError": "Before hooks failed - aborting execution"
}
```

Verify:
- test.txt does not exist
- after.txt does not exist

## 004-context-variables-in-hooks

Tests that context variables are properly passed to hooks.

```yaml
config:
  repoPath: /tmp/t_hooks_integration_004
  hooks:
    hooks:
      after:
        - run: |
            cat > summary.txt << EOF
            Total blocks: ${totalBlocks}
            Executed: ${executedActions}
            Operations: ${operations}
            EOF
    vars:
      CUSTOM_VAR: "test123"
```

```sh nesl
#!nesl [@three-char-SHA-256: cv1]
action = "file_write"
path = "/tmp/t_hooks_integration_004/file1.txt"
content = "First file"
#!end_cv1

#!nesl [@three-char-SHA-256: cv2]
action = "file_read"
path = "/tmp/t_hooks_integration_004/file1.txt"
#!end_cv2
```

```json
{
  "success": true,
  "totalBlocks": 2,
  "executedActions": 2,
  "results": [
    {
      "seq": 1,
      "blockId": "cv1",
      "action": "file_write",
      "params": {
        "path": "file1.txt",
        "content": "First file"
      },
      "success": true
    },
    {
      "seq": 2,
      "blockId": "cv2",
      "action": "file_read",
      "params": {
        "path": "file1.txt"
      },
      "success": true,
      "data": "First file"
    }
  ],
  "parseErrors": []
}
```

Verify:
- summary.txt contains:
  ```
  Total blocks: 2
  Executed: 2
  Operations: file_write,file_read
  ```

## 005-loaf-yml-auto-creation

Tests that loaf.yml is created when missing and hooks are enabled.

```yaml
config:
  repoPath: /tmp/t_hooks_integration_005
  enableHooks: true
  createConfigIfMissing: true  # New option to add
```

```sh nesl
#!nesl [@three-char-SHA-256: lac]
action = "file_write"
path = "/tmp/t_hooks_integration_005/test.txt"
content = "Trigger config creation"
#!end_lac
```

```json
{
  "success": true,
  "totalBlocks": 1,
  "executedActions": 1,
  "results": [
    {
      "seq": 1,
      "blockId": "lac",
      "action": "file_write",
      "params": {
        "path": "test.txt",
        "content": "Trigger config creation"
      },
      "success": true
    }
  ],
  "parseErrors": [],
  "configCreated": true
}
```

Verify:
- loaf.yml exists with starter content
- test.txt exists
=== END FILE: /Users/stuart/repos/loaf/proj/comp/orch/test-data/integration/hooks-integration.md ===

=== START FILE: /Users/stuart/repos/loaf/proj/comp/hooks/src/detectShell.ts ===
/**
 * Detects the appropriate shell for the current platform
 * Used to provide better defaults for hooks on different OSes
 */
export function detectShell(): { shell: string; isWindows: boolean } {
  const isWindows = process.platform === 'win32';
  
  if (isWindows) {
    // On Windows, prefer PowerShell over cmd if available
    // PowerShell is more capable and handles Unix-style commands better
    const shell = process.env.ComSpec || 'cmd.exe';
    
    // Could enhance this to detect PowerShell availability
    // For now, we'll document that Windows users should use PowerShell-compatible commands
    return { shell, isWindows };
  }
  
  // Unix-like systems (Linux, macOS)
  const shell = process.env.SHELL || '/bin/sh';
  return { shell, isWindows };
}

/**
 * Provides platform-appropriate example commands
 */
export function getPlatformExamples(): { 
  gitAdd: string; 
  gitCommit: string; 
  gitPush: string;
  gitStash: string;
} {
  const { isWindows } = detectShell();
  
  // Git commands are the same across platforms when using Git Bash or PowerShell
  // These work on all platforms with Git installed
  return {
    gitAdd: 'git add -A',
    gitCommit: 'git commit -m "${COMMIT_MSG}"',
    gitPush: 'git push',
    gitStash: 'git stash --include-untracked'
  };
}
=== END FILE: /Users/stuart/repos/loaf/proj/comp/hooks/src/detectShell.ts ===

=== START FILE: /Users/stuart/repos/loaf/proj/comp/hooks/src/formatHookResult.ts ===
import type { CommandResult, HookResult } from './types.js';

/**
 * Formats array of command results into a HookResult
 * Overall success is true only if all commands succeeded
 * Collects errors from failed commands
 */
export function formatHookResult(results: CommandResult[]): HookResult {
  const errors: Array<{ command: string; error: string }> = [];
  let allSuccess = true;

  for (const result of results) {
    if (!result.success) {
      allSuccess = false;
      errors.push({
        command: result.command,
        error: result.error || 'Command failed'
      });
    }
  }

  return {
    success: allSuccess,
    executed: results.length,
    ...(errors.length > 0 && { errors })
  };
}
=== END FILE: /Users/stuart/repos/loaf/proj/comp/hooks/src/formatHookResult.ts ===

=== START FILE: /Users/stuart/repos/loaf/proj/comp/hooks/src/index.ts ===
import { promisify } from 'util';
import { exec } from 'child_process';
import { readFile } from 'fs/promises';
import { interpolateCommand } from './interpolateCommand.js';
import { validateCommand } from './validateCommand.js';
import { formatHookResult } from './formatHookResult.js';
import { parseYamlConfig } from './parseYamlConfig.js';
import { validateConfig } from './validateConfig.js';
import type { CommandResult } from './types.js';

// Public types
export interface HooksConfig {
  version?: number;
  hooks?: {
    before?: Command[];
    after?: Command[];
  };
  vars?: Record<string, string>;
}

export interface Command {
  run: string;
  continueOnError?: boolean;
  timeout?: number;
  cwd?: string;
}

export interface HookContext {
  [key: string]: string | number | boolean;
}

export interface HookResult {
  success: boolean;
  executed: number;
  errors?: Array<{
    command: string;
    error: string;
  }>;
}

// Promisified exec
const execAsync = promisify(exec);

// Main class
export class HooksManager {
  private config: HooksConfig;
  private repoPath: string;

  constructor(config?: HooksConfig, repoPath?: string) {
    this.config = config || { hooks: {}, vars: {} };
    this.repoPath = repoPath || process.cwd();
  }

  async runBefore(context?: HookContext): Promise<HookResult> {
    const commands = this.config.hooks?.before || [];
    return this.runCommands(commands, context);
  }

  async runAfter(context?: HookContext): Promise<HookResult> {
    const commands = this.config.hooks?.after || [];
    return this.runCommands(commands, context);
  }

  async loadConfig(path: string): Promise<HooksConfig> {
    try {
      const content = await readFile(path, 'utf8');
      const config = parseYamlConfig(content);
      
      const validation = validateConfig(config);
      if (!validation.valid) {
        throw new Error(`Invalid config: ${validation.error}`);
      }
      
      this.config = config;
      return config;
    } catch (error: any) {
      if (error.code === 'ENOENT') {
        throw new Error(`Config file not found: ${path}`);
      }
      throw error;
    }
  }

  private async runCommands(commands: Command[], context?: HookContext): Promise<HookResult> {
    const results: CommandResult[] = [];
    
    for (const cmd of commands) {
      try {
        // Interpolate variables
        const interpolatedCmd = interpolateCommand(cmd, this.config.vars || {}, context);
        
        // Validate command
        const validation = validateCommand(interpolatedCmd);
        if (!validation.valid) {
          const result: CommandResult = {
            command: cmd.run,
            success: false,
            error: validation.error || 'Invalid command'
          };
          results.push(result);
          
          if (!cmd.continueOnError) {
            break;
          }
          continue;
        }
        
        // Execute command
        const result = await this.executeCommand(interpolatedCmd);
        results.push({
          command: cmd.run,
          ...result
        });
        
        if (!result.success && !cmd.continueOnError) {
          break;
        }
      } catch (error: any) {
        const result: CommandResult = {
          command: cmd.run,
          success: false,
          error: error.message
        };
        results.push(result);
        
        if (!cmd.continueOnError) {
          break;
        }
      }
    }
    
    return formatHookResult(results);
  }

  private async executeCommand(cmd: Command): Promise<Omit<CommandResult, 'command'>> {
    const timeout = cmd.timeout || 30000;
    const options = {
      cwd: cmd.cwd || this.repoPath,
      timeout,
      encoding: 'utf8' as const
    };
    
    try {
      const { stdout, stderr } = await execAsync(cmd.run, options);
      return {
        success: true,
        stdout: stdout || '',
        stderr: stderr || ''
      };
    } catch (error: any) {
      return {
        success: false,
        error: error.message,
        stdout: error.stdout || '',
        stderr: error.stderr || ''
      };
    }
  }
}
=== END FILE: /Users/stuart/repos/loaf/proj/comp/hooks/src/index.ts ===

=== START FILE: /Users/stuart/repos/loaf/proj/comp/hooks/src/interpolateCommand.ts ===
import type { Command, HookContext } from './types.js';

/**
 * Interpolates variables in a command's run string
 * Replaces ${VAR} patterns with values from vars and context
 * Context values override vars values
 * @throws Error if a variable is not found
 */
export function interpolateCommand(
  cmd: Command,
  vars: Record<string, string>,
  context?: HookContext
): Command {
  // Create a new command object to avoid mutation
  const interpolated = { ...cmd };
  
  // Build combined variable map (context overrides vars)
  const allVars: Record<string, string> = { ...vars };
  if (context) {
    // Convert context values to strings
    for (const [key, value] of Object.entries(context)) {
      allVars[key] = String(value);
    }
  }

  // Replace variables in the run string
  let runString = cmd.run;
  
  // First, handle escaped dollar signs
  runString = runString.replace(/\\\$/g, '\x00ESCAPED_DOLLAR\x00');
  
  // Find and replace all ${VAR} patterns
  const varPattern = /\$\{([^}]+)\}/g;
  const matches = runString.match(varPattern);
  
  if (matches) {
    for (const match of matches) {
      const varName = match.slice(2, -1); // Remove ${ and }
      
      if (!(varName in allVars)) {
        throw new Error(`Variable not found: ${varName}`);
      }
      
      runString = runString.replace(match, allVars[varName]);
    }
  }
  
  // Restore escaped dollar signs
  runString = runString.replace(/\x00ESCAPED_DOLLAR\x00/g, '$');
  
  interpolated.run = runString;
  return interpolated;
}
=== END FILE: /Users/stuart/repos/loaf/proj/comp/hooks/src/interpolateCommand.ts ===

=== START FILE: /Users/stuart/repos/loaf/proj/comp/hooks/src/parseYamlConfig.ts ===
import { load } from 'js-yaml';
import type { HooksConfig } from './types.js';

/**
 * Parses YAML content into HooksConfig object
 * @throws Error if YAML is invalid
 */
export function parseYamlConfig(content: string): HooksConfig {
  try {
    // Empty string returns null from js-yaml
    if (content.trim() === '') {
      return null as any;
    }

    const parsed = load(content);
    
    // js-yaml returns undefined for empty documents sometimes
    if (parsed === undefined) {
      return null as any;
    }

    return parsed as HooksConfig;
  } catch (error: any) {
    throw new Error(`Invalid YAML: ${error.message}`);
  }
}
=== END FILE: /Users/stuart/repos/loaf/proj/comp/hooks/src/parseYamlConfig.ts ===

=== START FILE: /Users/stuart/repos/loaf/proj/comp/hooks/src/types.ts ===
// Re-export public types from index
export type { HooksConfig, Command, HookContext, HookResult } from './index.js';

// Internal types
export interface CommandResult {
  command: string;
  success: boolean;
  error?: string;
  stdout?: string;
  stderr?: string;
}

export interface ValidationResult {
  valid: boolean;
  error?: string;
}
=== END FILE: /Users/stuart/repos/loaf/proj/comp/hooks/src/types.ts ===

=== START FILE: /Users/stuart/repos/loaf/proj/comp/hooks/src/validateCommand.ts ===
import type { Command, ValidationResult } from './types.js';

/**
 * Validates a command object has required properties and valid values
 * Checks: run is non-empty string, timeout is positive if present
 */
export function validateCommand(cmd: Command): ValidationResult {
  // Check if cmd is an object
  if (!cmd || typeof cmd !== 'object') {
    return {
      valid: false,
      error: 'Command must be an object'
    };
  }

  // Check for run property
  if (!('run' in cmd)) {
    return {
      valid: false,
      error: 'Command must have \'run\' property'
    };
  }

  // Check run is a string
  if (typeof cmd.run !== 'string') {
    return {
      valid: false,
      error: 'Command run must be a string'
    };
  }

  // Check run is not empty (after trimming)
  if (cmd.run.trim() === '') {
    return {
      valid: false,
      error: 'Command run string cannot be empty'
    };
  }

  // Check timeout if present
  if ('timeout' in cmd && cmd.timeout !== undefined) {
    if (typeof cmd.timeout !== 'number' || cmd.timeout <= 0) {
      return {
        valid: false,
        error: 'Timeout must be positive'
      };
    }
  }

  return { valid: true };
}
=== END FILE: /Users/stuart/repos/loaf/proj/comp/hooks/src/validateCommand.ts ===

=== START FILE: /Users/stuart/repos/loaf/proj/comp/hooks/src/validateConfig.ts ===
import type { HooksConfig, ValidationResult } from './types.js';

/**
 * Validates a parsed config object has correct structure
 * Checks hooks is object, before/after are arrays, commands are objects
 * vars is object with string values
 */
export function validateConfig(config: any): ValidationResult {
  // Empty config is valid
  if (!config || typeof config !== 'object') {
    return {
      valid: false,
      error: 'Config must be an object'
    };
  }

  // Check hooks if present
  if ('hooks' in config && config.hooks !== undefined) {
    if (typeof config.hooks !== 'object' || config.hooks === null) {
      return {
        valid: false,
        error: 'hooks must be an object'
      };
    }

    // Check before hooks
    if ('before' in config.hooks && config.hooks.before !== undefined) {
      if (!Array.isArray(config.hooks.before)) {
        return {
          valid: false,
          error: 'hooks.before must be an array'
        };
      }

      // Check each before command
      for (const cmd of config.hooks.before) {
        if (typeof cmd !== 'object' || cmd === null) {
          return {
            valid: false,
            error: 'hook commands must be objects'
          };
        }
      }
    }

    // Check after hooks
    if ('after' in config.hooks && config.hooks.after !== undefined) {
      if (!Array.isArray(config.hooks.after)) {
        return {
          valid: false,
          error: 'hooks.after must be an array'
        };
      }

      // Check each after command
      for (const cmd of config.hooks.after) {
        if (typeof cmd !== 'object' || cmd === null) {
          return {
            valid: false,
            error: 'hook commands must be objects'
          };
        }
      }
    }
  }

  // Check vars if present
  if ('vars' in config && config.vars !== undefined) {
    if (typeof config.vars !== 'object' || config.vars === null || Array.isArray(config.vars)) {
      return {
        valid: false,
        error: 'vars must be an object'
      };
    }

    // Check all var values are strings
    for (const value of Object.values(config.vars)) {
      if (typeof value !== 'string') {
        return {
          valid: false,
          error: 'var values must be strings'
        };
      }
    }
  }

  return { valid: true };
}
=== END FILE: /Users/stuart/repos/loaf/proj/comp/hooks/src/validateConfig.ts ===

=== START FILE: /Users/stuart/repos/loaf/use-listener/instruct.md ===

Prioritize substance, clarity, and depth. Challenge all my proposals, designs, and conclusions as hypotheses to be tested. Sharpen follow-up questions for precision, surfacing hidden assumptions, trade offs, and failure modes early. Default to terse, logically structured, information-dense responses unless detailed exploration is required. Skip unnecessary praise unless grounded in evidence. Explicitly acknowledge uncertainty when applicable. Always propose at least one alternative framing. Accept critical debate as normal and preferred. Treat all factual claims as provisional unless cited or clearly justified. Cite when appropriate. Acknowledge when claims rely on inference or incomplete information. Favor accuracy over sounding certain.

check anything online when it feels relevant.  good to compare our thoughts/assumptions with what other people are actually doing and thinking

when asked to share your thoughts (like if user says "wdyt"), then walk it out and talk it out gradually, incrementally, slowly, and thoughtfully.  challenge me so we can succeed overall

dont fall into the trap of equating "implementation" with "low-level".  implementation decisions can be high-level when they affect the system's fundamental behavior

IMPORTANT EDIT INSTRUCTIONS NOTE:

- always use full absolute file paths for edit instructions





use the following syntax to execute operations on the user's computer:

# NESL Tool API Reference

## Syntax
```sh
#!nesl [@three-char-SHA-256: q8r]
action = "tool_name"
param1 = <<'EOT_q8r'
value line 1
value line 2
EOT_q8r
param2 = "value"
#!end_q8r
```

Constraints:
- Block ID must be exactly 3 characters
- Always use heredocs (`<<'EOT_[id]'...EOT_[id]`) for file contents
- All paths must be absolute

## Tools

### `file_write`
Write content to file (creates or overwrites)  
- `path`
- `content`

### `file_replace_text`
Replace exactly one text occurrence  
- `path`
- `old_text`
- `new_text` 

### `file_replace_lines`
Replace the given line(s) with the supplied `new_content` string
- `path`
- `lines` eg "3" or a range like "2-13"
- `new_content` 

### `file_read`
Read file contents  
- `path` 

### `file_read_numbered`
Read file with line numbers  
- `path`

### `files_read`
Read multiple files  
- `paths`


if you need to run any bash commands, share them with me separately and i will manually run them myself for you
=== END FILE: /Users/stuart/repos/loaf/use-listener/instruct.md ===

=== START FILE: /Users/stuart/repos/loaf/xd5_ref.md ===
# XD5 LLM Quick Reference

## Core Principle
Documentation maintains dependency graphs for deterministic context assembly. Initial dependencies are hypotheses - implementation discovers reality. The STOP protocol ensures documentation evolves to match actual dependencies.

## File Structure
```
<repo>/
└── proj/
    ├── doc/
    │   ├── API.md        # ⚠️ CRITICAL: All dependencies + exports
    │   ├── ABSTRACT.md   # 60-word purpose + 300-word overview + brief spec in EARS format (The Easy Approach to Requirements Syntax)
    │   └── ARCH.md       # Technical decisions, constraints
    ├── test-data/        # Test cases as JSON/MD files
    │   ├── unit/         # Unit test data
    │   └── integration/  # Integration test data
    ├── test/             # Minimal harnesses loading test-data
    │   ├── unit/         # Unit test harnesses
    │   └── integration/  # Integration test harnesses
    ├── test-intn/        # Integration tests for dependencies
    ├── src/              # Implementation
    └── comp/             # Sub-components (recursive) - do not need 'proj' dirs
```

## API.md Template
```markdown
# Component: {name}

## Component Type
standard | types-only

## Dependencies
[Provisional - updated via STOP protocol when implementation reveals actual needs]

Mark internal component status: [PLANNED], [IN-PROGRESS], or [IMPLEMENTED]
External dependencies do not need status markers.

```yaml
dependencies:
  # Initial hypothesis based on design
  proj/comp/payment:                                       # [PLANNED]
    functions: [validateCard, processRefund] # may change 
    types: [PaymentResult, CardType]
    errors: [PaymentError]
  
  proj/comp/auth:                                          # [IMPLEMENTED]
    functions: [checkPermission, validateToken]
    types: [User, TokenPayload]
  
  proj/comp/logger:                                        # [IN-PROGRESS]
    functions: [logTransaction]  # Audit requirement
  
  proj/comp/payment-types: "*"  # Wildcard for types-only  # [IMPLEMENTED] 
  
  external/lodash:
    functions: [groupBy, mapValues]
  
  external/@stripe/stripe-js:
    types: [Stripe, PaymentIntent]
    functions: [loadStripe]
```

## Exports
[Structured YAML for dependency graph tooling, then prose descriptions]

```yaml
exports:
  functions: [functionName1, functionName2]
  types: [Type1, Type2, Type3]
  classes:
    ClassName:
      methods: [method1, method2]
  errors: [CustomError1, CustomError2]
```

### {functionName}
- **Signature**: `{functionName}(param: Type) -> ReturnType`
- **Purpose**: Single sentence.
- **Throws**: `{ErrorType}` when {condition}
- **Test-data**: `test-data/{path}/{functionName}.json` [PLANNED|IMPLEMENTED]



## Workflow

### Core Flow: Design → Test → Implement

1. **Write docs**: ABSTRACT.md → ARCH.md → API.md (provisional)
2. **Design tests**: E2E hypothesis → Decompose → Unit tests  
3. **Implement**: Discover real dependencies → Update docs → Complete code

### Test Authority & Evolution

**Tests Are Source of Truth (But Not Infallible)**
- Tests define what code SHOULD do
- During debug: ALWAYS fix code to match tests first
- Test errors discovered? Ask human: "I believe test X is incorrect because Y. Should I update it?"
- NEVER auto-modify tests while debugging
- Each test change needs explicit approval

### Detailed Flow

1. **E2E Test Hypothesis** - Write component test-data (expect evolution)
2. **Pseudocode** - Rough implementation to discover structure
3. **Extract Functions** - Identify & extract all pure functions
4. **Unit Tests** - Write test-data for each function
5. **Implement Functions** - Red/green/debug (fix code, not tests)
6. **Revise E2E Tests** - Align with discovered behavior (ask human)
7. **Wire Component** - Connect tested functions
8. **Debug E2E** - Fix code until green

**Debug Protocol**: Test fails? → Try fixing code → Still failing? → Consider test error → Request human approval for any test change

**If docs are wrong**: STOP → Update docs → Update tests → Continue



### Critical Implementation Rules

**Initial Docs Are Hypotheses**: 
- First API.md contains best guesses
- Dependencies WILL be wrong
- This is expected and healthy
- Discovery through implementation is the goal

**🛑 STOP Protocol**: When implementation reveals doc errors:
1. STOP immediately
2. Update API.md/ARCH.md
3. Continue with correct docs

**Test Immutability**: 
- Test harnesses = frozen after creation
- Test data = only change with human approval
- Fix code, not tests (unless explicitly approved)

**Dependency Updates**:
- Add to API.md as discovered
- Include transitive deps if needed for understanding
- External deps must be explicit

## Test Data Format
```json
{
  "cases": [
    {
      "name": "descriptive name",
      "input": [arg1, arg2],
      "expected": {result},
      "throws": "ErrorType"  // optional
    }
  ]
}
```

## Quick Checks

Before implementing:
- [ ] API.md declares all exports?
- [ ] Dependencies section updated?
- [ ] Test data files created?

During implementation:
- [ ] Tests fail first (red phase)?
- [ ] Docs match reality? (if not → STOP)
- [ ] All imports declared in API.md?

## Common Patterns

**Extract pure functions during pseudocode**:
```javascript
// Pseudocode reveals:
// extractedFn: validateInput(x) -> bool
// extractedFn: processData(data) -> result
```

**Types-only components**: No test/ or src/, only doc/

**Path conventions**: All relative to `<repo>/`
- Component: `proj/comp/{name}`
- Nested: `proj/comp/{parent}/comp/{child}`


# update 

- need to update this so that we save our pseudocde in some sort of documetnation, maybe temp documentation.  so if we implement the fucntiosn to unit test, we dont get confused later about how theyre supposed to be used.

- ideally, each extracted function unit-testable function would be in its own file.  for parallelism with the unit test files

- TESTING PATHS

dont save files directly to `/tmp/`.  save them to a dir in the tmp dir taht is named with the name of the test preceedd by 't_', eg `/tmp/t_move-nonexistent-file`

like: 


### 003-move-nonexistent-file

```sh nesl
#!nesl [@three-char-SHA-256: mnf]
action = "file_move"
old_path = "/tmp/t_move-nonexistent-file/ghost.txt"
new_path = "/tmp/t_move-nonexistent-file/nowhere.txt"
#!end_mnf
```

```json
{
  "success": false,
  "error": "file_move: Source file not found '/tmp/t_move-nonexistent-file/ghost.txt' (ENOENT)"
}
```



consider using EARS somehow for specs/reqs: EARS: The Easy Approach to Requirements Syntax

for dependency blocks in docs api, do not include external dependencies!!
=== END FILE: /Users/stuart/repos/loaf/xd5_ref.md ===

=== START FILE: /Users/stuart/repos/loaf/package.json ===
{
  "name": "loaf",
  "version": "0.1.0",
  "description": "LLM Output Actuation Framework",
  "type": "module",
  "engines": {
    "node": ">=20.0.0"
  },
  "scripts": {
    "build": "tsc --noEmit",
    "dev": "tsx watch proj/src/index.ts",
    "start": "tsx proj/src/index.ts",
    "test": "vitest run",
    "test:watch": "vitest watch",
    "test:run": "vitest run",
    "test:debug": "vitest run --reporter=verbose --no-coverage",
    "test:handles": "node --expose-gc ./node_modules/.bin/vitest run --reporter=verbose --no-coverage",
    "typecheck": "tsc --noEmit",
    "lint": "eslint proj/**/*.ts",
    "lint:fix": "eslint proj/**/*.ts --fix",
    "listener": "tsx use-listener/test-listener-live.ts"
  },
  "dependencies": {
    "clipboardy": "^4.0.0",
    "js-yaml": "^4.1.0",
    "marked": "^12.0.0",
    "nesl-js": "github:nesl-lang/nesl-js"
  },
  "devDependencies": {
    "@types/js-yaml": "^4.0.9",
    "@types/node": "^20.19.9",
    "@typescript-eslint/eslint-plugin": "^7.0.0",
    "@typescript-eslint/parser": "^7.0.0",
    "eslint": "^8.56.0",
    "ts-node": "^10.9.2",
    "tsx": "^4.7.0",
    "typescript": "^5.8.3",
    "vitest": "^1.2.0"
  },
  "keywords": [
    "llm",
    "actions",
    "filesystem",
    "nesl"
  ],
  "author": "",
  "license": "MIT"
}
=== END FILE: /Users/stuart/repos/loaf/package.json ===

