=== START FILE: /Users/stuart/repos/loaf/proj/comp/orch/src/index.ts ===
import type { LoafAction, ParseResult, ParseError } from '../../nesl-action-parser/src/index.js';
import { parseNeslResponse } from '../../nesl-action-parser/src/index.js';
import type { FileOpResult } from '../../fs-ops/src/index.js';
import { FsOpsExecutor } from '../../fs-ops/src/index.js';
import type { HooksConfig, HookContext, HookResult } from '../../hooks/src/index.js';
import { HooksManager } from '../../hooks/src/index.js';
import { FsGuard } from '../../fs-guard/src/index.js';
import { ExecExecutor } from '../../exec/src/index.js';
import { load as loadYaml } from 'js-yaml';
import { readFile, access } from 'fs/promises';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';
import { createStarterConfig } from './createStarterConfig.js';
import { loadConfig } from './loadConfig.js';
import type { LoafConfig } from './types.js';

export interface ExecutionResult {
  success: boolean;
  totalBlocks: number;
  executedActions: number;
  results: ActionResult[];
  parseErrors: ParseError[];
  fatalError?: string;
  hookErrors?: {
    before?: string[];
    after?: string[];
  };
  configCreated?: boolean;
  debug?: {
    parseDebug?: any;
  };
}

export interface ActionResult {
  seq: number;
  blockId: string;
  action: string;
  params: Record<string, any>;
  success: boolean;
  error?: string;
  data?: any;
}

export interface LoafOptions {
  repoPath?: string;
  gitCommit?: boolean;
  hooks?: HooksConfig;
  enableHooks?: boolean;
  createConfigIfMissing?: boolean;
}

export class Loaf {
  private options: LoafOptions;
  private executors: Map<string, (action: LoafAction) => Promise<FileOpResult>> | null = null;
  private hooksManager: HooksManager | null = null;
  private config: LoafConfig | null = null;

  constructor(options: LoafOptions = {}) {
    this.options = {
      repoPath: options.repoPath || process.cwd(),
      gitCommit: options.gitCommit ?? true,
      hooks: options.hooks,
      enableHooks: options.enableHooks ?? true,
      createConfigIfMissing: options.createConfigIfMissing ?? false
    };
  }

  /**
   * Parse and execute all NESL blocks in LLM output
   * Executes all valid actions sequentially, collecting both successes and failures
   */
  async execute(llmOutput: string): Promise<ExecutionResult> {
    const hookErrors: ExecutionResult['hookErrors'] = {};
    let configCreated = false;

    try {
      // Initialize hooks if enabled and not already initialized
      if (this.options.enableHooks && !this.hooksManager) {
        try {
          const initResult = await this.initializeHooks();
          configCreated = initResult.configCreated || false;
        } catch (error) {
          return {
            success: false,
            totalBlocks: 0,
            executedActions: 0,
            results: [],
            parseErrors: [],
            fatalError: `Failed to initialize hooks: ${error instanceof Error ? error.message : String(error)}`
          };
        }
      }

      // Run before hooks
      if (this.hooksManager) {
        try {
          const beforeResult = await this.hooksManager.runBefore();
          if (!beforeResult.success) {
            // Before hook failure is fatal
            return {
              success: false,
              totalBlocks: 0,
              executedActions: 0,
              results: [],
              parseErrors: [],
              hookErrors: {
                before: beforeResult.errors?.map(e => `${e.command}: ${e.error}`) || ['Unknown before hook error']
              },
              fatalError: 'Before hooks failed - aborting execution'
            };
          }
        } catch (error) {
          return {
            success: false,
            totalBlocks: 0,
            executedActions: 0,
            results: [],
            parseErrors: [],
            fatalError: `Before hooks threw unexpected error: ${error instanceof Error ? error.message : String(error)}`
          };
        }
      }

      // Parse NESL blocks
      const parseResult = await parseNeslResponse(llmOutput);

      // Debug info captured in parseResult.debug

      // Initialize executors if needed
      if (!this.executors) {
        try {
          await this.initializeExecutors();
        } catch (error) {
          return {
            success: false,
            totalBlocks: parseResult.summary.totalBlocks,
            executedActions: 0,
            results: [],
            parseErrors: parseResult.errors,
            fatalError: `Failed to initialize executors: ${error instanceof Error ? error.message : String(error)}`
          };
        }
      }

      // Execute each valid action sequentially
      const results: ActionResult[] = [];
      let seq = 1;

      for (const action of parseResult.actions) {
        const result = await this.executeAction(action, seq++);
        results.push(result);
      }

      // Calculate execution success (before considering after hooks)
      const allActionsSucceeded = results.every(r => r.success);
      const noParseErrors = parseResult.errors.length === 0;
      const executionSuccess = allActionsSucceeded && noParseErrors;

      // Run after hooks with context
      if (this.hooksManager) {
        try {
          // Build rich context for hooks
          const modifiedFiles = new Set<string>();
          const operations: string[] = [];
          const errors: string[] = [];

          for (const result of results) {
            if (result.action.startsWith('file_') && result.params.path) {
              modifiedFiles.add(result.params.path);
            }

            operations.push(`${result.action}${result.success ? '' : ' (failed)'}`);

            if (!result.success && result.error) {
              errors.push(`${result.action}: ${result.error}`);
            }
          }

          const afterContext: HookContext = {
            success: executionSuccess,
            executedActions: results.length,
            totalBlocks: parseResult.summary.totalBlocks,
            modifiedFiles: Array.from(modifiedFiles).join(','),
            operations: operations.join(','),
            errors: errors.join('; '),
            errorCount: errors.length
          };

          const afterResult = await this.hooksManager.runAfter(afterContext);
          if (!afterResult.success) {
            // After hook failure is non-fatal but recorded
            hookErrors.after = afterResult.errors?.map(e => `${e.command}: ${e.error}`) || ['Unknown after hook error'];
          }
        } catch (error) {
          // After hook unexpected errors are also non-fatal
          hookErrors.after = [`After hooks threw unexpected error: ${error instanceof Error ? error.message : String(error)}`];
        }
      }

      return {
        success: executionSuccess && !hookErrors.after, // After hook errors affect overall success
        totalBlocks: parseResult.summary.totalBlocks,
        executedActions: results.length,
        results,
        parseErrors: parseResult.errors,
        ...(Object.keys(hookErrors).length > 0 && { hookErrors }),
        ...(configCreated && { configCreated }),
        debug: {
          parseDebug: parseResult.debug
        }
      };

    } catch (error) {
      // Only truly unexpected errors should reach here
      return {
        success: false,
        totalBlocks: 0,
        executedActions: 0,
        results: [],
        parseErrors: [],
        fatalError: `Unexpected error in execute: ${error instanceof Error ? error.message : String(error)}`
      };
    }
  }

  /**
   * Initialize hooks manager with configuration
   */
  private async initializeHooks(): Promise<{ configCreated: boolean }> {
    let configCreated = false;

    // Ensure config is loaded
    if (!this.config) {
      this.config = await loadConfig(this.options.repoPath!);
    }

    if (this.options.hooks) {
      // Use provided configuration
      this.hooksManager = new HooksManager(this.options.hooks, {}, this.options.repoPath);
    } else if (this.config.hooks) {
      // Use hooks from loaded config
      this.hooksManager = new HooksManager(this.config.hooks, this.config.vars, this.options.repoPath);
    } else if (this.options.createConfigIfMissing) {
      // Create starter config if missing
      const loafYmlPath = join(this.options.repoPath!, 'loaf.yml');
      try {
        await access(loafYmlPath);
      } catch (error: any) {
        if (error.code === 'ENOENT') {
          configCreated = await createStarterConfig(this.options.repoPath!);
          if (configCreated) {
            // Reload config
            this.config = await loadConfig(this.options.repoPath!);
            if (this.config.hooks) {
              this.hooksManager = new HooksManager(this.config.hooks, this.options.repoPath);
            }
          }
        }
      }
    }

    return { configCreated };
  }

  /**
   * Initialize action executors with configuration
   */
  private async initializeExecutors(): Promise<void> {
    // Load configuration
    this.config = await loadConfig(this.options.repoPath!);

    // Create fs-guard
    const fsGuard = new FsGuard(
      this.config['fs-guard'] || {
        allowed: [`${this.options.repoPath}/**`, '/tmp/**'],
        denied: ['/**/.git/**', '/**/.ssh/**', '/etc/**', '/sys/**', '/proc/**']
      },
      this.options.repoPath!
    );

    // Create executors
    const fsOps = new FsOpsExecutor(fsGuard);
    const exec = new ExecExecutor();

    // Load unified-design.yaml for routing
    const __filename = fileURLToPath(import.meta.url);
    const __dirname = dirname(__filename);
    const yamlPath = join(__dirname, '../../../../unified-design.yaml');
    const yamlContent = await readFile(yamlPath, 'utf8');
    const design = loadYaml(yamlContent) as any;

    // Build routing table from YAML
    this.executors = new Map();

    for (const [actionName, actionDef] of Object.entries(design.tools)) {
      const executorName = (actionDef as any).executor || this.inferExecutor(actionName, actionDef);

      switch (executorName) {
        case 'fs-ops':
          this.executors.set(actionName, (action) => fsOps.execute(action));
          break;
        case 'exec':
          this.executors.set(actionName, (action) => exec.execute(action));
          break;
        // Skip unimplemented executors
        case 'context':
        case 'git':
          break;
        default:
          console.warn(`Unknown executor: ${executorName} for action: ${actionName}`);
      }
    }
  }

  /**
   * Infer executor from action name/type when not explicitly defined
   * Temporary fallback until all YAML entries have executor field
   */
  private inferExecutor(actionName: string, actionDef: any): string | null {
    // File/dir operations go to fs-ops
    if (actionName.startsWith('file_') || actionName.startsWith('files_') ||
      actionName.startsWith('dir_') || ['ls', 'grep', 'glob'].includes(actionName)) {
      return 'fs-ops';
    }

    // Exec operations
    if (actionName === 'exec') {
      return 'exec';
    }

    // Context operations (future)
    if (actionName.startsWith('context_')) {
      return 'context';
    }

    // Git operations (future)
    if (actionName.startsWith('git_') || actionName === 'undo') {
      return 'git';
    }

    return null;
  }

  /**
   * Execute a single action and format the result
   * Never throws - all errors returned in ActionResult
   */
  private async executeAction(action: LoafAction, seq: number): Promise<ActionResult> {
    const executor = this.executors?.get(action.action);

    if (!executor) {
      return {
        seq,
        blockId: action.metadata.blockId,
        action: action.action,
        params: action.parameters,
        success: false,
        error: `Unknown action: ${action.action}`
      };
    }

    try {
      // Add default cwd for exec actions if not specified
      const enhancedAction = action.action === 'exec' && !action.parameters.cwd
        ? { ...action, parameters: { ...action.parameters, cwd: this.options.repoPath } }
        : action;

      const result = await executor(enhancedAction);

      return {
        seq,
        blockId: action.metadata.blockId,
        action: action.action,
        params: action.parameters,
        success: result.success,
        ...(result.error && { error: result.error }),
        ...(result.data !== undefined && { data: result.data }),
        // Include exec-specific fields at top level
        ...(action.action === 'exec' && {
          data: {
            stdout: result.stdout,
            stderr: result.stderr,
            exit_code: result.exit_code
          }
        })
      };

    } catch (error) {
      // Executors should never throw, but handle just in case
      return {
        seq,
        blockId: action.metadata.blockId,
        action: action.action,
        params: action.parameters,
        success: false,
        error: `Unexpected executor error: ${error instanceof Error ? error.message : String(error)}`
      };
    }
  }
}
=== END FILE: /Users/stuart/repos/loaf/proj/comp/orch/src/index.ts ===

=== START FILE: /Users/stuart/repos/loaf/proj/comp/hooks/test/integration/git-integration.test.ts ===
import { describe, test, expect, beforeEach, afterEach } from 'vitest';
import { existsSync, mkdirSync, rmSync, writeFileSync, readFileSync } from 'fs';
import { join } from 'path';
import { execSync } from 'child_process';
import { Loaf } from '../../../orch/src/index.js';

const TEST_BASE = '/tmp/t_hooks_git_integration';
const REPO_DIR = join(TEST_BASE, 'repo');
const REMOTE_DIR = join(TEST_BASE, 'remote.git');

describe('Git Hooks Integration', () => {
  beforeEach(() => {
    // Clean slate
    if (existsSync(TEST_BASE)) {
      rmSync(TEST_BASE, { recursive: true, force: true });
    }
    mkdirSync(TEST_BASE, { recursive: true });
    
    // Initialize bare remote
    execSync(`git init --bare ${REMOTE_DIR}`, { stdio: 'pipe' });
    
    // Initialize local repo
    mkdirSync(REPO_DIR);
    execSync('git init', { cwd: REPO_DIR, stdio: 'pipe' });
    execSync('git config user.email "test@example.com"', { cwd: REPO_DIR });
    execSync('git config user.name "Test User"', { cwd: REPO_DIR });
    execSync(`git remote add origin ${REMOTE_DIR}`, { cwd: REPO_DIR });
    
    // Initial commit (can't push empty repo)
    writeFileSync(join(REPO_DIR, 'README.md'), '# Test Repo\n');
    execSync('git add README.md', { cwd: REPO_DIR });
    execSync('git commit -m "Initial commit"', { cwd: REPO_DIR });
    execSync('git push -u origin main', { cwd: REPO_DIR });
  });

  afterEach(() => {
    if (existsSync(TEST_BASE)) {
      rmSync(TEST_BASE, { recursive: true, force: true });
    }
  });

  test('happy path - stash, modify, commit, push', async () => {
    // Setup: Create loaf.yml with git hooks
    // Use relative paths since hooks run with cwd=REPO_DIR
    const loafConfig = `version: 1
hooks:
  before:
    - run: echo "BEFORE_HOOK_RAN" > .hook-trace
    - run: git add .hook-trace
    - run: git stash push --keep-index --include-untracked
      continueOnError: true
      
  after:
    - run: echo "AFTER_HOOK_RAN" >> .hook-trace
    - run: git add -A
    - run: git commit -m "\${COMMIT_MSG}"
    - run: git push origin main

vars:
  COMMIT_MSG: "AI-assisted changes via NESL"
`;
    writeFileSync(join(REPO_DIR, 'loaf.yml'), loafConfig);
    
    // Create uncommitted changes that should be stashed
    writeFileSync(join(REPO_DIR, 'uncommitted.txt'), 'This should be stashed');
    writeFileSync(join(REPO_DIR, 'staged.txt'), 'This is staged');
    execSync('git add staged.txt', { cwd: REPO_DIR });
    
    // NESL input that creates new files
    const neslInput = `#!nesl [@three-char-SHA-256: gf1]
action = "file_write"
path = "${REPO_DIR}/generated.txt"
content = "Generated by NESL"
#!end_gf1

#!nesl [@three-char-SHA-256: gf2]
action = "file_write"  
path = "${REPO_DIR}/src/feature.js"
content = "export const feature = () => 'implemented';"
#!end_gf2`;

    // // Execute with hooks - force config reload
    // console.log('\n=== TEST DIAGNOSTICS ===');
    // console.log('REPO_DIR:', REPO_DIR);
    // console.log('loaf.yml exists:', existsSync(join(REPO_DIR, 'loaf.yml')));
    
    // // Show loaf.yml content
    // const loafYmlContent = readFileSync(join(REPO_DIR, 'loaf.yml'), 'utf8');
    // console.log('loaf.yml content:');
    // console.log(loafYmlContent);
    // console.log('--- end loaf.yml ---\n');
    
    // // Check if .hook-trace exists before execution
    // console.log('.hook-trace exists before execution:', existsSync(join(REPO_DIR, '.hook-trace')));
    
    const loaf = new Loaf({ 
      repoPath: REPO_DIR,
      enableHooks: true,
      hooks: undefined  // Explicitly undefined to trigger loaf.yml load
    });
    
    // console.log('\n=== EXECUTING NESL ===');
    const result = await loaf.execute(neslInput);
    
    // // Debug: log the full result to see what's happening
    // console.log('\nExecution result:', JSON.stringify(result, null, 2));
    
    // // Check hook trace immediately after execution
    // console.log('\n=== POST-EXECUTION DIAGNOSTICS ===');
    // console.log('.hook-trace exists after execution:', existsSync(join(REPO_DIR, '.hook-trace')));
    // if (existsSync(join(REPO_DIR, '.hook-trace'))) {
    //   const traceContent = readFileSync(join(REPO_DIR, '.hook-trace'), 'utf8');
    //   console.log('.hook-trace raw content:', JSON.stringify(traceContent));
    //   console.log('.hook-trace display:\n' + traceContent);
    // }
    
    // // Check git status
    // console.log('\nGit status:');
    // console.log(execSync('git status --porcelain', { cwd: REPO_DIR, encoding: 'utf8' }));
    
    // // Check for hook errors in result
    // if (result.hookErrors) {
    //   console.log('\nHook errors found:', result.hookErrors);
    // }
    
    // Verify execution succeeded
    expect(result.success).toBe(true);
    expect(result.executedActions).toBe(2);
    expect(result.hookErrors).toBeUndefined();
    
    // Verify working directory is clean (all changes committed)
    const status = execSync('git status --porcelain', { 
      cwd: REPO_DIR, 
      encoding: 'utf8' 
    }).trim();
    expect(status).toBe('');
    
    // Verify files were created and committed
    expect(existsSync(join(REPO_DIR, 'generated.txt'))).toBe(true);
    expect(existsSync(join(REPO_DIR, 'src/feature.js'))).toBe(true);
    
    // Verify stash was created (should have our uncommitted files)
    const stashList = execSync('git stash list', { 
      cwd: REPO_DIR, 
      encoding: 'utf8' 
    });
    expect(stashList).toContain('stash@{0}');
    
    // Verify commit was made with correct message
    const lastCommit = execSync('git log -1 --pretty=%B', { 
      cwd: REPO_DIR, 
      encoding: 'utf8' 
    }).trim();
    expect(lastCommit).toBe('AI-assisted changes via NESL');
    
    // Verify push succeeded by checking remote
    const remoteLogs = execSync('git log --oneline', { 
      cwd: REMOTE_DIR, 
      encoding: 'utf8' 
    });
    expect(remoteLogs).toContain('AI-assisted changes via NESL');
    
    // Poll-based verification that remote has the files
    // (Clone to verify push worked completely)
    const cloneDir = join(TEST_BASE, 'verify-clone');
    execSync(`git clone ${REMOTE_DIR} ${cloneDir}`, { stdio: 'pipe' });
    
    let attempts = 0;
    const maxAttempts = 10;
    let filesExist = false;
    
    while (attempts < maxAttempts && !filesExist) {
      filesExist = existsSync(join(cloneDir, 'generated.txt')) && 
                   existsSync(join(cloneDir, 'src/feature.js'));
      if (!filesExist) {
        await new Promise(resolve => setTimeout(resolve, 100));
        attempts++;
      }
    }
    
    expect(filesExist).toBe(true);
    
    // Verify file contents in clone
    const generatedContent = readFileSync(join(cloneDir, 'generated.txt'), 'utf8');
    expect(generatedContent).toBe('Generated by NESL');
    
    // CRITICAL: Verify hooks actually executed
    const hookTrace = readFileSync(join(REPO_DIR, '.hook-trace'), 'utf8');
    expect(hookTrace).toContain('BEFORE_HOOK_RAN');
    expect(hookTrace).toContain('AFTER_HOOK_RAN');
    
    // Verify the specific files that were committed (not just that a commit exists)
    const commitFiles = execSync('git show --name-only --pretty="" HEAD', {
      cwd: REPO_DIR,
      encoding: 'utf8'
    }).trim().split('\n');
    expect(commitFiles).toContain('generated.txt');
    expect(commitFiles).toContain('src/feature.js');
    expect(commitFiles).not.toContain('uncommitted.txt'); // Should be in stash, not commit
  });
});
=== END FILE: /Users/stuart/repos/loaf/proj/comp/hooks/test/integration/git-integration.test.ts ===

=== START FILE: /Users/stuart/repos/loaf/proj/comp/hooks/src/index.ts ===
import { promisify } from 'util';
import { exec } from 'child_process';
import { readFile } from 'fs/promises';
import { interpolateCommand } from './interpolateCommand.js';
import { validateCommand } from './validateCommand.js';
import { formatHookResult } from './formatHookResult.js';
import { parseYamlConfig } from './parseYamlConfig.js';
import { validateConfig } from './validateConfig.js';
import type { CommandResult } from './types.js';

// Public types
export interface HooksConfig {
  version?: number;
  before?: Command[];
  after?: Command[];
  vars?: Record<string, string>;
}

export interface Command {
  run: string;
  continueOnError?: boolean;
  timeout?: number;
  cwd?: string;
}

export interface HookContext {
  [key: string]: string | number | boolean;
}

export interface HookResult {
  success: boolean;
  executed: number;
  errors?: Array<{
    command: string;
    error: string;
  }>;
}

// Promisified exec
const execAsync = promisify(exec);

// Main class
export class HooksManager {
  private config: HooksConfig;
  private vars: Record<string, string>;
  private repoPath: string;

  constructor(config?: HooksConfig, vars?: Record<string, string>, repoPath?: string) {
    this.config = config || {};
    this.vars = vars || {};
    this.repoPath = repoPath || process.cwd();
  }

  async runBefore(context?: HookContext): Promise<HookResult> {
    const commands = this.config.before || [];
    return this.runCommands(commands, context);
  }

  async runAfter(context?: HookContext): Promise<HookResult> {
    const commands = this.config.after || [];
    return this.runCommands(commands, context);
  }

  async loadAndSetConfig(path: string): Promise<HooksConfig> {
    try {
      const content = await readFile(path, 'utf8');
      const config = parseYamlConfig(content);

      const validation = validateConfig(config);
      if (!validation.valid) {
        throw new Error(`Invalid config: ${validation.error}`);
      }

      this.config = config.hooks || {};
      this.vars = config.vars || {};
      return config;
    } catch (error: any) {
      if (error.code === 'ENOENT') {
        throw new Error(`Config file not found: ${path}`);
      }
      throw error;
    }
  }

  private async runCommands(commands: Command[], context?: HookContext): Promise<HookResult> {
    const results: CommandResult[] = [];

    for (const cmd of commands) {
      try {
        // Interpolate variables
        const interpolatedCmd = interpolateCommand(cmd, this.vars, context);

        // Validate command
        const validation = validateCommand(interpolatedCmd);
        if (!validation.valid) {
          const result: CommandResult = {
            command: cmd.run,
            success: false,
            error: validation.error || 'Invalid command'
          };
          results.push(result);

          if (!cmd.continueOnError) {
            break;
          }
          continue;
        }

        // Execute command
        const result = await this.executeCommand(interpolatedCmd);

        results.push({
          command: cmd.run,
          ...result
        });

        if (!result.success && !cmd.continueOnError) {
          break;
        }
      } catch (error: any) {
        const result: CommandResult = {
          command: cmd.run,
          success: false,
          error: error.message
        };
        results.push(result);

        if (!cmd.continueOnError) {
          break;
        }
      }
    }

    return formatHookResult(results);
  }

  private async executeCommand(cmd: Command): Promise<Omit<CommandResult, 'command'>> {
    const timeout = cmd.timeout || 30000;
    const options = {
      cwd: cmd.cwd || this.repoPath,
      timeout,
      encoding: 'utf8' as const,
      shell: true  // Ensure shell interpretation for redirects
    };

    try {
      const { stdout, stderr } = await execAsync(cmd.run, options);
      return {
        success: true,
        stdout: stdout || '',
        stderr: stderr || ''
      };
    } catch (error: any) {
      return {
        success: false,
        error: error.message,
        stdout: error.stdout || '',
        stderr: error.stderr || ''
      };
    }
  }
}
=== END FILE: /Users/stuart/repos/loaf/proj/comp/hooks/src/index.ts ===

=== START FILE: /Users/stuart/repos/loaf/proj/comp/orch/src/types.ts ===
import type { HooksConfig } from '../../hooks/src/index.js';

export interface LoafConfig {
  version: number;
  hooks?: HooksConfig;
  vars?: Record<string, string>;
  'fs-guard'?: FsGuardConfig;
  'exec-guard'?: ExecGuardConfig; // future
}

export interface FsGuardConfig {
  allowed?: string[];
  denied?: string[];
  followSymlinks?: boolean;
}

export interface ExecGuardConfig {
  languages?: string[];
  timeout?: number;
}
=== END FILE: /Users/stuart/repos/loaf/proj/comp/orch/src/types.ts ===

=== START FILE: /Users/stuart/repos/loaf/proj/comp/orch/src/loadConfig.ts ===
import { readFile } from 'fs/promises';
import { join } from 'path';
import { load as loadYaml } from 'js-yaml';
import type { LoafConfig } from './types.js';

export async function loadConfig(repoPath: string): Promise<LoafConfig> {
  const configPath = join(repoPath, 'loaf.yml');

  try {
    const content = await readFile(configPath, 'utf8');
    const config = loadYaml(content) as LoafConfig;

    // Validate config structure
    if (!config || typeof config !== 'object') {
      throw new Error('Invalid config: must be an object');
    }

    if (!config.version) {
      throw new Error('Config missing version');
    }

    return config;
  } catch (error: any) {
    if (error.code === 'ENOENT') {
      // Return default config when file doesn't exist
      return {
        version: 1,
        'fs-guard': {
          allowed: [`${repoPath}/**`, '/tmp/**'],
          denied: ['/**/.git/**', '/**/.ssh/**', '/etc/**', '/sys/**', '/proc/**']
        }
      };
    }
    throw error;
  }
}
=== END FILE: /Users/stuart/repos/loaf/proj/comp/orch/src/loadConfig.ts ===

=== START FILE: /Users/stuart/repos/loaf/proj/comp/hooks/test/integration/hooks-basic.test.ts ===
import { describe, test, expect, beforeEach, afterEach } from 'vitest';
import { mkdirSync, rmSync, readFileSync, existsSync } from 'fs';
import { join } from 'path';
import { HooksManager } from '../../src/index.js';

const TEST_DIR = '/tmp/t_hooks_test';

describe('HooksManager Integration', () => {
  beforeEach(() => {
    // Create test directory
    if (!existsSync(TEST_DIR)) {
      mkdirSync(TEST_DIR, { recursive: true });
    }
  });

  afterEach(() => {
    // Clean up test directory
    if (existsSync(TEST_DIR)) {
      rmSync(TEST_DIR, { recursive: true, force: true });
    }
  });

  test('executes before and after hooks', async () => {
    const config = {
      hooks: {
        before: [
          { run: `echo 'before' > ${TEST_DIR}/before.txt` }
        ],
        after: [
          { run: `echo 'after' > ${TEST_DIR}/after.txt` }
        ]
      }
    };

    const hooks = new HooksManager(config.hooks, config.vars);
    
    // Run before hooks
    const beforeResult = await hooks.runBefore();
    expect(beforeResult.success).toBe(true);
    expect(beforeResult.executed).toBe(1);
    expect(existsSync(`${TEST_DIR}/before.txt`)).toBe(true);
    expect(readFileSync(`${TEST_DIR}/before.txt`, 'utf8').trim()).toBe('before');

    // Run after hooks
    const afterResult = await hooks.runAfter();
    expect(afterResult.success).toBe(true);
    expect(afterResult.executed).toBe(1);
    expect(existsSync(`${TEST_DIR}/after.txt`)).toBe(true);
    expect(readFileSync(`${TEST_DIR}/after.txt`, 'utf8').trim()).toBe('after');
  });

  test('variable interpolation works', async () => {
    const config = {
      hooks: {
        before: [
          { run: `echo '${TEST_DIR}/\${MSG}' > ${TEST_DIR}/var.txt` }
        ]
      },
      vars: {
        MSG: 'hello-world'
      }
    };

    const hooks = new HooksManager(config.hooks, config.vars);
    const result = await hooks.runBefore();
    
    expect(result.success).toBe(true);
    expect(readFileSync(`${TEST_DIR}/var.txt`, 'utf8').trim()).toBe(`${TEST_DIR}/hello-world`);
  });

  test('context overrides vars', async () => {
    const config = {
      hooks: {
        after: [
          { run: `echo '\${STATUS}' > ${TEST_DIR}/status.txt` }
        ]
      },
      vars: {
        STATUS: 'from-config'
      }
    };

    const hooks = new HooksManager(config.hooks, config.vars);
    const result = await hooks.runAfter({ STATUS: 'from-context' });
    
    expect(result.success).toBe(true);
    expect(readFileSync(`${TEST_DIR}/status.txt`, 'utf8').trim()).toBe('from-context');
  });

  test('continueOnError allows execution to continue', async () => {
    const config = {
      hooks: {
        before: [
          { run: 'false', continueOnError: true },  // Will fail
          { run: `echo 'second' > ${TEST_DIR}/second.txt` }
        ]
      }
    };

    const hooks = new HooksManager(config.hooks, config.vars);
    const result = await hooks.runBefore();
    
    expect(result.success).toBe(false);
    expect(result.executed).toBe(2);
    expect(result.errors).toHaveLength(1);
    expect(existsSync(`${TEST_DIR}/second.txt`)).toBe(true);
  });

  test('stops on error without continueOnError', async () => {
    const config = {
      hooks: {
        before: [
          { run: 'false' },  // Will fail
          { run: `echo 'should not run' > ${TEST_DIR}/should-not-exist.txt` }
        ]
      }
    };

    const hooks = new HooksManager(config.hooks, config.vars);
    const result = await hooks.runBefore();
    
    expect(result.success).toBe(false);
    expect(result.executed).toBe(1);
    expect(result.errors).toHaveLength(1);
    expect(existsSync(`${TEST_DIR}/should-not-exist.txt`)).toBe(false);
  });

  test('timeout kills long-running commands', async () => {
    const config = {
      hooks: {
        before: [
          { run: 'sleep 5', timeout: 100 }  // 100ms timeout
        ]
      }
    };

    const hooks = new HooksManager(config.hooks, config.vars);
    const start = Date.now();
    const result = await hooks.runBefore();
    const duration = Date.now() - start;
    
    expect(result.success).toBe(false);
    expect(result.errors).toHaveLength(1);
    expect(duration).toBeLessThan(1000); // Should timeout quickly
  });

  test('loads config from YAML file', async () => {
    const yamlPath = `${TEST_DIR}/loaf.yml`;
    const yamlContent = `
version: 1
hooks:
  before:
    - run: echo 'from yaml' > ${TEST_DIR}/yaml.txt
vars:
  TEST: value
`;
    
    // Write YAML file
    const { writeFileSync } = await import('fs');
    writeFileSync(yamlPath, yamlContent);

    const hooks = new HooksManager();
    const config = await hooks.loadAndSetConfig(yamlPath);
    
    expect(config.version).toBe(1);
    expect(config.vars?.TEST).toBe('value');
    
    // Run hooks to verify they work
    const result = await hooks.runBefore();
    expect(result.success).toBe(true);
    expect(readFileSync(`${TEST_DIR}/yaml.txt`, 'utf8').trim()).toBe('from yaml');
  });

  test('custom cwd works', async () => {
    const subDir = `${TEST_DIR}/subdir`;
    mkdirSync(subDir, { recursive: true });
    
    // Use Node.js to create a cross-platform test
    // This avoids shell-specific differences
    const testScript = process.platform === 'win32' 
      ? 'node -e "require(\'fs\').writeFileSync(\'test-cwd.txt\', \'cwd-test\')"'
      : 'node -e "require(\'fs\').writeFileSync(\'test-cwd.txt\', \'cwd-test\')"';
    
    const config = {
      hooks: {
        before: [
          { run: testScript, cwd: subDir }
        ]
      }
    };

    const hooks = new HooksManager(config.hooks, config.vars);
    const result = await hooks.runBefore();
    
    expect(result.success).toBe(true);
    
    // Verify the file was created in the correct directory
    const testFilePath = join(subDir, 'test-cwd.txt');
    expect(existsSync(testFilePath)).toBe(true);
    expect(readFileSync(testFilePath, 'utf8')).toBe('cwd-test');
  });

  
});
=== END FILE: /Users/stuart/repos/loaf/proj/comp/hooks/test/integration/hooks-basic.test.ts ===

=== START FILE: /Users/stuart/repos/loaf/proj/comp/hooks/test/integration/hooks-abort.test.ts ===
import { describe, test, expect, beforeEach, afterEach } from 'vitest';
import { existsSync, mkdirSync, rmSync, writeFileSync } from 'fs';
import { join } from 'path';
import { Loaf } from '../../../orch/src/index.js';

describe('Hooks Abort Behavior', () => {
 test('hook failure aborts NESL execution', async () => {
   const TEST_PATH = '/tmp/t_hooks_abort_test';
   
   // Ensure clean state
   if (existsSync(TEST_PATH)) {
     rmSync(TEST_PATH, { recursive: true, force: true });
   }
   mkdirSync(TEST_PATH, { recursive: true });

   // Create loaf.yml with a failing command
   const loafConfig = `version: 1
hooks:
 before:
   - run: echo "FIRST_HOOK_RAN" > ${TEST_PATH}/first.txt
   - run: "cat /definitely/not/a/real/file/path.txt"  # This will fail
   - run: echo "SHOULD_NOT_RUN" > ${TEST_PATH}/should-not-exist.txt
     
 after:
   - run: echo "AFTER_SHOULD_NOT_RUN" > ${TEST_PATH}/after.txt
`;
   
   writeFileSync(join(TEST_PATH, 'loaf.yml'), loafConfig);

   // NESL that would create files if executed
   const neslInput = `#!nesl [@three-char-SHA-256: hfa]
action = "file_write"
path = "${TEST_PATH}/nesl-output.txt"
content = "This should not be written"
#!end_hfa`;

   const loaf = new Loaf({ 
     repoPath: TEST_PATH,
     enableHooks: true
   });
   
   const result = await loaf.execute(neslInput);
   
   // Verify the execution failed
   expect(result.success).toBe(false);
   expect(result.totalBlocks).toBe(0);
   expect(result.executedActions).toBe(0);
   expect(result.fatalError).toBe('Before hooks failed - aborting execution');
   expect(result.hookErrors?.before).toBeDefined();
   expect(result.hookErrors?.before?.[0]).toMatch(/cat.*No such file/);
   
   // Verify only the first hook ran
   expect(existsSync(join(TEST_PATH, 'first.txt'))).toBe(true);
   expect(existsSync(join(TEST_PATH, 'should-not-exist.txt'))).toBe(false);
   
   // Verify NESL didn't execute
   expect(existsSync(join(TEST_PATH, 'nesl-output.txt'))).toBe(false);
   
   // Verify after hooks didn't run
   expect(existsSync(join(TEST_PATH, 'after.txt'))).toBe(false);
   
   // Cleanup
   rmSync(TEST_PATH, { recursive: true, force: true });
 });
});
=== END FILE: /Users/stuart/repos/loaf/proj/comp/hooks/test/integration/hooks-abort.test.ts ===

=== START FILE: /Users/stuart/repos/loaf/proj/comp/orch/test/execute.test.ts ===
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { readFileSync, existsSync, rmSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';
import { marked, Token } from 'marked';
import { Loaf } from '../src/index.js';
import { clearActionSchemaCache } from '../../nesl-action-parser/src/index.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const testPath = join(__dirname, '../test-data/execute/basic-operations.md');
const mdContent = readFileSync(testPath, 'utf8');

const tokens = marked.lexer(mdContent);
const codeBlocks = tokens.filter(t => t.type === 'code') as Array<Token & { type: 'code', text: string, lang?: string }>;
const testNames = tokens
  .filter(t => t.type === 'heading' && 'depth' in t && t.depth === 3)
  .map(t => (t as any).text as string);

const testFiles = [
  '/tmp/test.txt',
  '/tmp/first.txt',
  '/tmp/second.txt',
  '/tmp/bad.txt',
  '/tmp/duplicate.txt',
  '/tmp/good.txt',
  '/tmp/does-not-exist.txt',
  '/tmp/read-test.txt',
  '/tmp/source-file.txt',
  '/tmp/destination-file.txt',
  '/tmp/replace-single.txt',
  '/tmp/replace-all.txt',
  '/tmp/multiline.txt',
  '/tmp/multiple-foo.txt',
  '/tmp/count-test.txt',
  '/tmp/move-source.txt',
  '/tmp/move-dest.txt',
  '/tmp/empty-replace.txt',
  '/tmp/parent-test.txt'
];

const testDirs = [
  '/tmp/new',
  '/tmp/007-file-move-success',
  '/tmp/016-file-move-creates-parent-dirs',
  '/tmp/017-files-read-multiple',
  '/tmp/018-files-read-with-missing'
];

describe('Loaf.execute()', () => {
  let loaf: Loaf;

  beforeEach(() => {
    // Clear the action schema cache to pick up latest definitions
    clearActionSchemaCache();
    loaf = new Loaf();
    // Clean up files
    for (const path of testFiles) {
      try {
        if (existsSync(path)) rmSync(path);
      } catch (err) {
        // Continue cleanup even if one fails
      }
    }
    // Clean up directories
    for (const path of testDirs) {
      try {
        if (existsSync(path)) rmSync(path, { recursive: true, force: true });
      } catch (err) {
        // Continue cleanup even if one fails
      }
    }
  });

  afterEach(() => {
    // Clean up files
    for (const path of testFiles) {
      try {
        if (existsSync(path)) rmSync(path);
      } catch (err) {
        // Continue cleanup even if one fails
      }
    }
    // Clean up directories
    for (const path of testDirs) {
      try {
        if (existsSync(path)) rmSync(path, { recursive: true, force: true });
      } catch (err) {
        // Continue cleanup even if one fails
      }
    }
  });

  testNames.forEach((name, i) => {
    const baseIndex = i * 2;
    it(name, async () => {
      const input = codeBlocks[baseIndex].text;
      const expected = JSON.parse(codeBlocks[baseIndex + 1].text);
      const result = await loaf.execute(input);

      // Remove debug field for comparison since test data doesn't include it
      const { debug, ...resultWithoutDebug } = result;
      expect(resultWithoutDebug).toEqual(expected);
    });
  });
});
=== END FILE: /Users/stuart/repos/loaf/proj/comp/orch/test/execute.test.ts ===

=== START FILE: /Users/stuart/repos/loaf/proj/comp/fs-ops/src/index.ts ===
/**
 * fs-ops - File system operations executor for loaf
 * 
 * Handles all file and directory operations from parsed NESL actions
 */

import type { LoafAction } from '../../nesl-action-parser/src/index.js';
import type { FsGuard } from '../../fs-guard/src/index.js';
import { writeFile, mkdir, unlink, rename, readFile } from 'fs/promises';
import { dirname } from 'path';
import { formatNodeError } from './formatNodeError.js';
import { fileExists } from './fileSystemUtils.js';
import { replaceText } from './replaceText.js';
import { extractNumberedLines } from './extractNumberedLines.js';

export interface FileOpResult {
  success: boolean;
  data?: any;
  error?: string;
}

export class FileOpError extends Error {
  constructor(
    message: string,
    public code: string,
    public path?: string,
    public operation?: string
  ) {
    super(message);
    this.name = 'FileOpError';
  }
}

/**
 * File system operations executor with security guard
 */
export class FsOpsExecutor {
  private handlers: Map<string, (action: LoafAction) => Promise<FileOpResult>>;

  constructor(private guard: FsGuard) {
    this.handlers = new Map([
      ['file_write', this.handleFileWrite.bind(this)],
      ['file_replace_text', this.handleFileReplaceText.bind(this)],
      ['file_replace_all_text', this.handleFileReplaceAllText.bind(this)],
      ['file_delete', this.handleFileDelete.bind(this)],
      ['file_move', this.handleFileMove.bind(this)],
      ['file_read', this.handleFileRead.bind(this)],
      ['files_read', this.handleFilesRead.bind(this)],
      ['file_read_numbered', this.handleFileReadNumbered.bind(this)],
      ['file_replace_lines', this.handleFileReplaceLines.bind(this)],
      ['dir_create', this.handleDirCreate.bind(this)],
      ['dir_delete', this.handleDirDelete.bind(this)],
      ['ls', this.handleLs.bind(this)],
      ['grep', this.handleGrep.bind(this)],
      ['glob', this.handleGlob.bind(this)]
    ]);
  }

  /**
   * Execute a file system operation with guard checks
   */
  async execute(action: LoafAction): Promise<FileOpResult> {
    try {
      // Check fs-guard permissions first
      const guardResult = await this.guard.check(action);
      if (!guardResult.allowed) {
        return {
          success: false,
          error: `fs-guard violation: ${guardResult.reason}`
        };
      }

      const handler = this.handlers.get(action.action);
      if (!handler) {
        return {
          success: false,
          error: `Unknown action: ${action.action}`
        };
      }

      return await handler(action);
    } catch (error: any) {
      // This should never happen - handlers should catch their own errors
      return {
        success: false,
        error: `Unexpected error in execute: ${error.message}`
      };
    }
  }

  /**
   * Handle file_move action - moves/renames a file
   * Creates parent directories for destination if needed
   * Overwrites destination if it exists
   */
  private async handleFileMove(action: LoafAction): Promise<FileOpResult> {
  const { old_path, new_path } = action.parameters;

  try {
    // Pre-flight check for better error messages
    const sourceExists = await fileExists(old_path);

    if (!sourceExists) {
      return {
        success: false,
        error: `file_move: Source file not found '${old_path}' (ENOENT)`
      };
    }

    // Check if destination exists (for overwrote flag)
    const destExists = await fileExists(new_path);

    // Create parent directories for destination
    const parentDir = dirname(new_path);
    await mkdir(parentDir, { recursive: true });

    // Move the file
    await rename(old_path, new_path);

    const result: FileOpResult = {
      success: true,
      data: {
        old_path,
        new_path
      }
    };

    if (destExists) {
      result.data.overwrote = true;
    }

    return result;

  } catch (error: any) {
    return {
      success: false,
      error: formatNodeError(error, old_path, 'rename', new_path)
    };
  }
}

  /**
   * Handle file_delete action - removes a file
   */
  private async handleFileDelete(action: LoafAction): Promise<FileOpResult> {
  const { path } = action.parameters;

  try {
    await unlink(path);

    return {
      success: true,
      data: {
        path
      }
    };

  } catch (error: any) {
    return {
      success: false,
      error: formatNodeError(error, path, 'unlink')
    };
  }
}

  /**
   * Handle file_write action - writes/creates/overwrites a file with content
   * Automatically creates parent directories if needed
   */
  private async handleFileWrite(action: LoafAction): Promise<FileOpResult> {
  const { path, content } = action.parameters;

  try {
    // Create parent directories if needed
    const parentDir = dirname(path);
    await mkdir(parentDir, { recursive: true });

    // Write file
    await writeFile(path, content, 'utf8');
    const bytesWritten = Buffer.byteLength(content, 'utf8');

    // Temporary debug for test 004
    if (path.includes('move-to-existing-file')) {
      // console.log(`DEBUG: Wrote file ${path}`);
      const exists = await fileExists(path);
      // console.log(`DEBUG: File exists after write: ${exists}`);
    }

    return {
      success: true,
      data: {
        path,
        bytesWritten
      }
    };

  } catch (error: any) {
    return {
      success: false,
      error: formatNodeError(error, path, 'open')
    };
  }
}

  /**
   * Handle file_read action - reads file content
   */
  private async handleFileRead(action: LoafAction): Promise<FileOpResult> {
  const { path } = action.parameters;

  try {
    const content = await readFile(path, 'utf8');

    return {
      success: true,
      data: {
        path,
        content
      }
    };

  } catch (error: any) {
    return {
      success: false,
      error: formatNodeError(error, path, 'open')
    };
  }
}

  /**
   * Handle file_read_numbered action - reads file content with line numbers
   * Returns specified lines with line numbers prepended
   * If lines parameter is missing, reads all lines
   * If some lines are out of range, returns available content with error
   */
  private async handleFileReadNumbered(action: LoafAction): Promise<FileOpResult> {
  const { path, lines, delimiter = ": " } = action.parameters;

  try {
    const content = await readFile(path, 'utf8');

    // Extract and number the requested lines
    const { result, outOfRange } = extractNumberedLines(content, lines, delimiter);

    // If out of range, return error with partial content
    if (outOfRange) {
      return {
        success: false,
        error: `file_read_numbered: Requested lines ${outOfRange.requested} but file only has ${outOfRange.actual} lines`,
        data: {
          path,
          content: result
        }
      };
    }

    return {
      success: true,
      data: {
        path,
        content: result
      }
    };

  } catch (error: any) {
    // Check if it's our custom validation error
    if (error.message && error.message.startsWith('Invalid line')) {
      return {
        success: false,
        error: `file_read_numbered: ${error.message}`
      };
    }

    return {
      success: false,
      error: formatNodeError(error, path, 'open')
    };
  }
}

  /**
   * Handle file_replace_lines action - replaces specified lines in a file
   * Supports single line ("4") or range ("23-43") specifications
   * Preserves line endings and handles edge cases
   */
  private async handleFileReplaceLines(action: LoafAction): Promise<FileOpResult> {
  const { path, lines, new_content } = action.parameters;

  try {
    // Read existing file content
    const content = await readFile(path, 'utf8');

    // Handle empty file edge case
    if (content === '') {
      return {
        success: false,
        error: `file_replace_lines: Line range ${lines} is out of bounds (file has 0 lines)`
      };
    }

    // Split into lines, preserving empty lines
    // Check if content ends with a newline
    const endsWithNewline = content.match(/\r?\n$/);
    const fileLines = content.split(/\r?\n|\r/);

    // If the file ends with a newline, split gives us an extra empty element
    // Remove it for line counting, but remember it existed
    if (endsWithNewline && fileLines[fileLines.length - 1] === '') {
      fileLines.pop();
    }

    const totalLines = fileLines.length;

    // Parse line specification
    let startLine: number;
    let endLine: number;

    if (!lines || lines === '') {
      return {
        success: false,
        error: `file_replace_lines: Invalid line specification '${lines}'`
      };
    }

    if (lines.includes('-')) {
      // Range format: "23-43"
      const parts = lines.split('-');
      if (parts.length !== 2) {
        return {
          success: false,
          error: `file_replace_lines: Invalid line specification '${lines}'`
        };
      }

      startLine = parseInt(parts[0], 10);
      endLine = parseInt(parts[1], 10);

      if (isNaN(startLine) || isNaN(endLine)) {
        return {
          success: false,
          error: `file_replace_lines: Invalid line specification '${lines}'`
        };
      }

      if (startLine < 1 || endLine < 1) {
        return {
          success: false,
          error: `file_replace_lines: Invalid line specification '${lines}'`
        };
      }

      if (startLine > endLine) {
        return {
          success: false,
          error: `file_replace_lines: Invalid line range '${lines}' (start must be <= end)`
        };
      }
    } else {
      // Single line format: "4"
      startLine = parseInt(lines, 10);
      if (isNaN(startLine) || startLine < 1) {
        return {
          success: false,
          error: `file_replace_lines: Invalid line specification '${lines}'`
        };
      }
      endLine = startLine;
    }



    // Check if lines are out of range
    if (startLine > totalLines || endLine > totalLines) {
      return {
        success: false,
        error: `file_replace_lines: Line range ${lines} is out of bounds (file has ${totalLines} lines)`
      };
    }

    // Split new content into lines
    // Empty content should produce one empty line, not zero lines
    const newLines = new_content.split(/\r?\n|\r/);

    // Reconstruct the file with replaced lines
    const resultLines: string[] = [];

    // Add lines before the replacement range
    for (let i = 0; i < startLine - 1; i++) {
      resultLines.push(fileLines[i]);
    }

    // Add the new content
    resultLines.push(...newLines);

    // Add lines after the replacement range
    for (let i = endLine; i < totalLines; i++) {
      resultLines.push(fileLines[i]);
    }

    // Join back with newlines
    let result = resultLines.join('\n');

    // If the original file ended with a newline, preserve it
    if (endsWithNewline) {
      result += '\n';
    }

    // Write the file back
    await writeFile(path, result, 'utf8');

    const linesReplaced = endLine - startLine + 1;

    return {
      success: true,
      data: {
        path,
        lines_replaced: linesReplaced
      }
    };

  } catch (error: any) {
    return {
      success: false,
      error: formatNodeError(error, path, 'open')
    };
  }
}

  /**
   * Handle files_read action - reads multiple files and returns their contents
   * Parses multi-line paths parameter, one absolute path per line
   * Returns an array of file contents in the same order as the paths
   */
  private async handleFilesRead(action: LoafAction): Promise<FileOpResult> {
  const { paths } = action.parameters;

  // Parse the multi-line paths string
  const pathList = paths
    .split('\n')
    .map(line => line.trim())
    .filter(line => line.length > 0);  // Remove empty lines

  if (pathList.length === 0) {
    return {
      success: false,
      error: 'files_read: No paths provided'
    };
  }

  // Read all files, collecting content and errors
  const results: Array<{ path: string; content?: string; error?: string }> = [];

  for (const filePath of pathList) {
    try {
      const content = await readFile(filePath, 'utf8');
      results.push({ path: filePath, content });
    } catch (error: any) {
      // Collect error for this file
      const errorMsg = formatNodeError(error, filePath, 'open');
      results.push({ path: filePath, error: errorMsg });
    }
  }

  // Check if any files failed to read
  const failedFiles = results.filter(r => r.error);
  if (failedFiles.length > 0) {
    // Return error listing all failed files
    const errorDetails = failedFiles
      .map(f => `  ${f.path}: ${f.error}`)
      .join('\n');
    return {
      success: false,
      error: `files_read: Failed to read ${failedFiles.length} file(s):\n${errorDetails}`
    };
  }

  // All files read successfully - return contents as array
  const contents = results.map(r => r.content!);

  return {
    success: true,
    data: {
      paths: pathList,
      content: contents
    }
  };
}

  /**
   * Handle file_replace_text action - replaces EXACTLY ONE occurrence
   * Fails if old_text appears 0 or 2+ times
   */
  private async handleFileReplaceText(action: LoafAction): Promise<FileOpResult> {
  const { path, old_text, new_text } = action.parameters;

  // Validate old_text is not empty
  if (!old_text || old_text.length === 0) {
    return {
      success: false,
      error: 'file_replace_text: old_text cannot be empty'
    };
  }

  try {
    // Read existing file content
    const content = await readFile(path, 'utf8');

    // Count occurrences first
    let count = 0;
    let searchIndex = 0;
    while (true) {
      const index = content.indexOf(old_text, searchIndex);
      if (index === -1) break;
      count++;
      searchIndex = index + old_text.length;
    }

    // Validate exactly one occurrence
    if (count === 0) {
      return {
        success: false,
        error: `file_replace_text: old_text not found in file`
      };
    }
    if (count > 1) {
      return {
        success: false,
        error: `file_replace_text: old_text appears ${count} times, must appear exactly once`
      };
    }

    // Replace the single occurrence
    const { result, replacements } = replaceText(content, old_text, new_text, 1);

    // Write updated content back
    await writeFile(path, result, 'utf8');

    return {
      success: true,
      data: {
        path,
        replacements
      }
    };

  } catch (error: any) {
    // Special case for empty old_text validation error
    if (error.message === 'old_text cannot be empty') {
      return {
        success: false,
        error: 'file_replace_text: old_text cannot be empty'
      };
    }

    return {
      success: false,
      error: formatNodeError(error, path, 'open')
    };
  }
}

  /**
   * Handle file_replace_all_text action - replaces all occurrences
   * If count provided, validates exact match
   */
  private async handleFileReplaceAllText(action: LoafAction): Promise<FileOpResult> {
  const { path, old_text, new_text, count } = action.parameters;

  // Validate old_text is not empty
  if (!old_text || old_text.length === 0) {
    return {
      success: false,
      error: 'file_replace_all_text: old_text cannot be empty'
    };
  }

  try {
    // Read existing file content
    const content = await readFile(path, 'utf8');

    // If count specified, validate it matches actual occurrences
    if (count !== undefined) {
      // Count actual occurrences
      let actualCount = 0;
      let searchIndex = 0;
      while (true) {
        const index = content.indexOf(old_text, searchIndex);
        if (index === -1) break;
        actualCount++;
        searchIndex = index + old_text.length;
      }

      if (actualCount !== count) {
        return {
          success: false,
          error: `file_replace_all_text: expected ${count} occurrences but found ${actualCount}`
        };
      }
    }

    // Replace all occurrences
    const { result, replacements } = replaceText(content, old_text, new_text);

    // Write updated content back
    await writeFile(path, result, 'utf8');

    return {
      success: true,
      data: {
        path,
        replacements
      }
    };

  } catch (error: any) {
    // Special case for empty old_text validation error
    if (error.message === 'old_text cannot be empty') {
      return {
        success: false,
        error: 'file_replace_all_text: old_text cannot be empty'
      };
    }

    return {
      success: false,
      error: formatNodeError(error, path, 'open')
    };
  }
}

  private async handleDirCreate(action: LoafAction): Promise<FileOpResult> {
    return { success: false, error: 'Not implemented' };
  }

  private async handleDirDelete(action: LoafAction): Promise<FileOpResult> {
    return { success: false, error: 'Not implemented' };
  }

  private async handleLs(action: LoafAction): Promise<FileOpResult> {
    return { success: false, error: 'Action not implemented: ls' };
  }

  private async handleGrep(action: LoafAction): Promise<FileOpResult> {
    return { success: false, error: 'Not implemented' };
  }

  private async handleGlob(action: LoafAction): Promise<FileOpResult> {
    return { success: false, error: 'Not implemented' };
  }
}

/**
 * Legacy function export for backward compatibility
 * @deprecated Use FsOpsExecutor class instead
 */
export async function executeFileOperation(action: LoafAction): Promise<FileOpResult> {
  throw new Error('Direct function call deprecated. Use FsOpsExecutor class.');
}
=== END FILE: /Users/stuart/repos/loaf/proj/comp/fs-ops/src/index.ts ===

=== START FILE: /Users/stuart/repos/loaf/proj/comp/fs-ops/test/integration/write_action_result.test.ts ===
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { readFileSync, rmSync, existsSync, readdirSync, statSync } from 'fs';
import { join } from 'path';
import { marked } from 'marked';
import { parseNeslResponse } from '../../../nesl-action-parser/src/index.js';
import { FsOpsExecutor } from '../../src/index.js';
import type { FsGuard } from '../../../fs-guard/src/index.js';

// Mock FsGuard that allows all operations
const mockGuard: FsGuard = {
  async check(action) {
    return { allowed: true };
  }
};

const executor = new FsOpsExecutor(mockGuard);

// Find all .cases.md files recursively
function findTestFiles(dir: string, files: string[] = []): string[] {
  const entries = readdirSync(dir);

  for (const entry of entries) {
    const fullPath = join(dir, entry);
    const stat = statSync(fullPath);

    if (stat.isDirectory()) {
      findTestFiles(fullPath, files);
    } else if (entry.endsWith('.cases.md')) {
      files.push(fullPath);
    }
  }

  return files;
}

describe('write_action_result tests', () => {
  let createdPaths: Set<string>;

  beforeEach(() => {
    createdPaths = new Set<string>();
  });

  afterEach(() => {
    // Clean up created test directories
    for (const path of createdPaths) {
      try {
        if (existsSync(path)) {
          rmSync(path, { recursive: true, force: true });
        }
      } catch (err) {
        // Continue silently
      }
    }
  });

  // Get test files from write_action_result directory
  const testDir = join(__dirname, '../../test-data/integration/write_action_result');
  const testFiles = findTestFiles(testDir).sort();

  testFiles.forEach(filepath => {
    const content = readFileSync(filepath, 'utf8');
    const tokens = marked.lexer(content);

    // Extract test group name from first h1 heading
    const groupHeading = tokens.find(t => t.type === 'heading' && t.depth === 1);
    const groupName = groupHeading?.text || 'Unknown Group';

    describe(groupName, () => {
      // Process h3 headings as test cases
      let currentTestName = '';
      let codeBlocks: string[] = [];

      /**
       * Process a test case with its code blocks
       * @param testName Name of the test
       * @param blocks Array of code blocks [writeBlock, actionBlock, resultBlock]
       */
      const processTest = (testName: string, blocks: string[]) => {
        it(testName, async () => {
          // Block 0: Write action (optional) - may contain multiple NESL blocks
          // Block 1: Test action
          // Block 2: Expected JSON result

          const writeBlock = blocks[0];
          const actionBlock = blocks[1];
          const resultBlock = blocks[2];

          // Execute write action if not empty
          if (writeBlock?.trim()) {

            const writeResult = await parseNeslResponse(writeBlock);

            // // Debug: log parse result
            // if (testName.includes('move-to-existing-file')) {
            //   console.log(`DEBUG: Parse errors: ${writeResult.errors.length}`);
            //   console.log(`DEBUG: Parse summary:`, writeResult.summary);
            //   if (writeResult.errors.length > 0) {
            //     writeResult.errors.forEach(err => {
            //       console.log(`DEBUG: Parse error:`, err);
            //     });
            //   }
            // }

            if (writeResult.errors.length > 0) {
              throw new Error(`Failed to parse write NESL: ${writeResult.errors.map(e => e.message).join(', ')}`);
            }

            // // Debug: log parsed actions
            // if (testName.includes('move-to-existing-file')) {
            //   console.log(`DEBUG: Parsed ${writeResult.actions.length} write actions`);
            //   writeResult.actions.forEach((action, i) => {
            //     console.log(`DEBUG: Action ${i}: ${action.action} path=${action.parameters?.path}`);
            //   });
            // }

            // Execute each write action
            for (const action of writeResult.actions) {
              const result = await executor.execute(action);
              // // Debug: log execution result
              // if (testName.includes('move-to-existing-file')) {
              //   console.log(`DEBUG: Executed ${action.action} path=${action.parameters?.path} success=${result.success}`);
              //   if (!result.success) {
              //     console.log(`DEBUG: Execution error:`, result.error);
              //   }
              // }
              // Track paths for cleanup
              if (action.parameters?.path) {
                const testDirMatch = action.parameters.path.match(/\/tmp\/t_[^\/]+/);
                if (testDirMatch) createdPaths.add(testDirMatch[0]);
              }
            }
          }

          // Execute test action
          const actionResult = await parseNeslResponse(actionBlock);
          if (actionResult.errors.length > 0) {
            throw new Error(`Failed to parse action NESL: ${actionResult.errors.map(e => e.message).join(', ')}`);
          }

          let testResult;
          for (const action of actionResult.actions) {
            testResult = await executor.execute(action);
            // Track paths for cleanup
            if (action.parameters?.path) {
              const testDirMatch = action.parameters.path.match(/\/tmp\/t_[^\/]+/);
              if (testDirMatch) createdPaths.add(testDirMatch[0]);
            }
            if (action.parameters?.old_path) {
              const testDirMatch = action.parameters.old_path.match(/\/tmp\/t_[^\/]+/);
              if (testDirMatch) createdPaths.add(testDirMatch[0]);
            }
            if (action.parameters?.new_path) {
              const testDirMatch = action.parameters.new_path.match(/\/tmp\/t_[^\/]+/);
              if (testDirMatch) createdPaths.add(testDirMatch[0]);
            }
          }

          // Verify result
          const expectedResult = JSON.parse(resultBlock);
          expect(testResult).toEqual(expectedResult);
        }, 30000);
      };

      // Parse tokens and create tests
      tokens.forEach((token, index) => {
        if (token.type === 'heading' && token.depth === 3) {
          // Process previous test if exists
          if (currentTestName && codeBlocks.length >= 2) {
            processTest(currentTestName, [...codeBlocks]);
          }

          // Start new test
          currentTestName = token.text;
          codeBlocks = [];
        } else if (token.type === 'code' && currentTestName) {
          codeBlocks.push(token.text);
        }
      });

      // Process final test
      if (currentTestName && codeBlocks.length >= 2) {
        processTest(currentTestName, [...codeBlocks]);
      }
    });
  });
});
=== END FILE: /Users/stuart/repos/loaf/proj/comp/fs-ops/test/integration/write_action_result.test.ts ===

=== START FILE: /Users/stuart/repos/loaf/proj/comp/fs-guard/tsconfig.json ===
{
  "extends": "../../../tsconfig.base.json",
  "compilerOptions": {
    "rootDir": "src",
    "outDir": "src"
  },
  "include": ["src/**/*"],
  "exclude": ["src/**/*.test.ts", "src/**/*.spec.ts"]
}
=== END FILE: /Users/stuart/repos/loaf/proj/comp/fs-guard/tsconfig.json ===

=== START FILE: /Users/stuart/repos/loaf/package.json ===
{
  "name": "loaf",
  "version": "0.1.0",
  "description": "LLM Output Actuation Framework",
  "type": "module",
  "engines": {
    "node": ">=20.0.0"
  },
  "scripts": {
    "build": "tsc --noEmit",
    "dev": "tsx watch proj/src/index.ts",
    "start": "tsx proj/src/index.ts",
    "test": "vitest run",
    "test:watch": "vitest watch",
    "test:run": "vitest run",
    "test:debug": "vitest run --reporter=verbose --no-coverage",
    "test:handles": "node --expose-gc ./node_modules/.bin/vitest run --reporter=verbose --no-coverage",
    "typecheck": "tsc --noEmit",
    "lint": "eslint proj/**/*.ts",
    "lint:fix": "eslint proj/**/*.ts --fix",
    "listener": "tsx use-listener/test-listener-live.ts"
  },
  "dependencies": {
    "clipboardy": "^4.0.0",
    "js-yaml": "^4.1.0",
    "marked": "^12.0.0",
    "nesl-js": "github:nesl-lang/nesl-js"
  },
  "devDependencies": {
    "@types/js-yaml": "^4.0.9",
    "@types/node": "^20.19.9",
    "@typescript-eslint/eslint-plugin": "^7.0.0",
    "@typescript-eslint/parser": "^7.0.0",
    "eslint": "^8.56.0",
    "ts-node": "^10.9.2",
    "tsx": "^4.7.0",
    "typescript": "^5.8.3",
    "vitest": "^1.2.0"
  },
  "keywords": [
    "llm",
    "actions",
    "filesystem",
    "nesl"
  ],
  "author": "",
  "license": "MIT"
}
=== END FILE: /Users/stuart/repos/loaf/package.json ===

=== START FILE: /Users/stuart/repos/loaf/tsconfig.json ===
{
  "compilerOptions": {
    // Modern output settings
    "target": "ES2022",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "lib": ["ES2022"],
    
    // Strict type checking
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "strictFunctionTypes": true,
    "strictBindCallApply": true,
    "strictPropertyInitialization": true,
    "noImplicitThis": true,
    "alwaysStrict": true,
    
    // Additional checks
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedIndexedAccess": true,
    
    // Output settings
    "outDir": "./dist",
    "rootDir": ".",
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    
    // Module resolution
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "resolveJsonModule": true,
    "forceConsistentCasingInFileNames": true,
    
    // Path mapping for cleaner imports
    "baseUrl": "."
  },
  "include": [
    "proj/**/*.ts"
  ],
  "exclude": [
    "node_modules",
    "dist",
    "**/test/**",
    "**/test-data/**"
  ]
}
=== END FILE: /Users/stuart/repos/loaf/tsconfig.json ===

=== START FILE: /Users/stuart/repos/loaf/proj/comp/hooks/doc/ABSTRACT.md ===
# Hooks Component

## Purpose (60 words)
Execute user-defined shell commands before and after NESL block execution. Enables VCS integration through configurable lifecycle hooks with variable interpolation, timeout control, and error handling. Loads configuration from loaf.yml files.

## Overview (300 words)
The hooks component provides lifecycle management for loaf operations, allowing users to define shell commands that run before and after NESL execution. This enables seamless version control integration without hardcoding VCS-specific logic into loaf itself.

Key features:
- Before/after hook execution with configurable commands
- Variable interpolation performed before shell execution for security
- Per-command timeout and error handling options
- YAML configuration loading from project and user directories
- Shell command escaping for safety

The component executes commands sequentially, failing fast on errors unless explicitly configured to continue. Variables are interpolated before passing to the shell, preventing injection attacks. Commands execute in the repository root by default with optional cwd override.

## Requirements (EARS format)
- The system SHALL execute before hooks prior to NESL execution
- The system SHALL execute after hooks following NESL execution
- The system SHALL interpolate variables before shell execution
- The system SHALL fail fast on command errors unless continueOnError is set
- The system SHALL respect per-command timeout values
- The system SHALL create starter loaf.yml if not exist
- The system SHALL load configuration from loaf.yml

# example

Example `loaf.yml`:

# Loaf configuration

```yaml
version: 1  # For future compatibility

hooks:
  before:
    - run: git stash --include-untracked
      
  after:
    - run: git add -A
    - run: git commit -m "${COMMIT_MSG}"
    - run: git push
      continueOnError: true
      timeout: 10000  # 10s for slow networks

# Variables available in commands
vars:
  COMMIT_MSG: "AI-assisted changes"
```

https://claude.ai/chat/d344370c-aaf5-46ec-9786-93cc208f7613
https://claude.ai/chat/4bdbd3d3-d3e6-4249-bce8-d19f882b2fba
=== END FILE: /Users/stuart/repos/loaf/proj/comp/hooks/doc/ABSTRACT.md ===

=== START FILE: /Users/stuart/repos/loaf/proj/comp/hooks/doc/API.md ===
# Component: hooks

## Component Type
standard

## Dependencies

```yaml
dependencies:
  external/js-yaml:
    functions: [load]
  
  external/shell-escape:
    functions: [escape]
  
  node:child_process:
    functions: [exec]
  
  node:util:
    functions: [promisify]
```

## Exports

```yaml
exports:
  classes:
    HooksManager:
      constructor: [config?: HooksConfig]
      methods: [runBefore, runAfter, loadConfig]
  types:
    - HooksConfig
    - Command
    - HookContext
    - HookResult
```

### HooksManager (class)
- **Purpose**: Manages lifecycle hooks for command execution
- **Constructor**: `new HooksManager(config?: HooksConfig)`
- **State**: Loaded configuration and variable context

### runBefore
- **Signature**: `async runBefore(context?: HookContext): Promise<HookResult>`
- **Purpose**: Execute all before hooks sequentially
- **Throws**: First command failure unless continueOnError

### runAfter  
- **Signature**: `async runAfter(context?: HookContext): Promise<HookResult>`
- **Purpose**: Execute all after hooks sequentially
- **Throws**: First command failure unless continueOnError

### loadConfig
- **Signature**: `async loadConfig(path: string): Promise<HooksConfig>`
- **Purpose**: Load hooks configuration from YAML file
- **Throws**: `Error` on invalid YAML or missing file

### HooksConfig (type)
```typescript
interface HooksConfig {
  hooks?: {
    before?: Command[];
    after?: Command[];
  };
  vars?: Record<string, string>;
}
```

### Command (type)
```typescript
interface Command {
  run: string;
  continueOnError?: boolean;
  timeout?: number;
  cwd?: string;
}
```

### HookContext (type)
```typescript
interface HookContext {
  [key: string]: string | number | boolean;
}
```

### HookResult (type)
```typescript
interface HookResult {
  success: boolean;
  executed: number;
  errors?: Array<{
    command: string;
    error: string;
  }>;
}
```
=== END FILE: /Users/stuart/repos/loaf/proj/comp/hooks/doc/API.md ===

=== START FILE: /Users/stuart/repos/loaf/proj/comp/hooks/doc/ARCH.md ===
# Hooks Architecture

## Design Decisions

### Variable Interpolation
- **Decision**: Interpolate before shell execution
- **Rationale**: Prevents shell injection, predictable behavior
- **Implementation**: Simple string replacement of ${VAR} patterns

### Error Handling
- **Decision**: Fail fast by default
- **Rationale**: Predictable, safe default for VCS operations
- **Override**: Per-command `continueOnError` flag

### Configuration Loading
1. Check `loaf.yml` in repository root

### Command Execution
- Internal shell execution using child_process.exec
- Default cwd is repository root
- Sequential execution (no parallelism)
- Promisified exec for async/await pattern

### Timeout Handling
- Per-command timeout configuration
- Kill entire process tree on timeout
- Default: 30 seconds

## Security Considerations
- Shell escaping via shell-escape library
- No dynamic command construction
- Variables interpolated before shell sees them

## Internal Implementation

### Shell Execution
- Direct use of `child_process.exec` with promisify wrapper
- Custom timeout implementation (exec doesn't support natively)
- Process killing on timeout using process.kill()
- Error standardization for consistent handling

### Process Management
```javascript
// Timeout approach
const timeoutPromise = new Promise((_, reject) => 
  setTimeout(() => reject(new Error('Command timeout')), timeout)
);
Promise.race([execPromise, timeoutPromise]);
```

=== END FILE: /Users/stuart/repos/loaf/proj/comp/hooks/doc/ARCH.md ===

=== START FILE: /Users/stuart/repos/loaf/proj/comp/orch/doc/API.md ===
# Component: loaf

## Component Type
standard

## Dependencies

```yaml
dependencies:
  proj/comp/nesl-action-parser:  # [IMPLEMENTED]
    functions: [parseNeslResponse]
    types: [ParseResult, LoafAction, ParseError, ValidationResult, TransformError]
  
  proj/comp/fs-ops:              # [PARTIALLY IMPLEMENTED]
    functions: [executeFileOperation]
    types: [FileOpResult]
    classes:
      FileOpError:
        extends: Error
  
  proj/comp/exec:                # [PLANNED]
    functions: [executeCommand]
    types: [ExecResult]
  
  proj/comp/hooks:               # [PLANNED]
    classes:
      HooksManager:
        constructor: [config?: HooksConfig]
        methods: [runBefore, runAfter, loadConfig]
    types: [HooksConfig, HookContext, HookResult]
  
  proj/comp/git-tx:              # [PLANNED - v1.2]
    functions: [ensureCleanRepo, commitChanges]
    types: [GitError]
  
  proj/comp/context:             # [PLANNED]
    functions: [addPath, removePath, listPaths, clearContext]
    types: [ContextError]
  
  external/nesl-js:
    functions: [parseNesl]
    types: [Block, ParseResult, ParseError]
```

## Exports

```yaml
exports:
  classes:
    Loaf:
      constructor: [options?: LoafOptions]
      methods: [execute]
  types: 
    - ExecutionResult
    - ActionResult  
    - LoafOptions
  # Note: ParseError is re-exported from nesl-action-parser
```

### Loaf (class)
- **Purpose**: Main orchestrator executing NESL blocks from LLM output
- **Constructor**: `new Loaf(options?: LoafOptions)`
- **State**: Maintains working directory and context set across execute() calls

### execute
- **Signature**: `async execute(llmOutput: string): Promise<ExecutionResult>`
- **Purpose**: Parse and execute all NESL blocks in LLM output, commit results
- **Process**: 
  1. Run before hooks (if enabled)
  2. Parse NESL blocks
  3. Convert to actions
  4. Execute all valid actions
  5. Run after hooks with execution context (if enabled)
  6. (v1.2: Git commit with summary)
- **Throws**: Never - all errors captured in ExecutionResult
- **Hook Context**: After hooks receive: `{ success: boolean, executedActions: number, totalBlocks: number }`
- **Test-data**: `test-data/execute/basic-operations.md` [IMPLEMENTED]

### ExecutionResult (type)
```typescript
interface ExecutionResult {
  success: boolean              // False if any action failed or hooks failed
  totalBlocks: number          // Count of NESL blocks found
  executedActions: number      // Count of actions attempted
  results: ActionResult[]      // All execution results
  parseErrors: ParseError[]    // NESL parsing errors
  fatalError?: string         // System failure (v1.2: will include git errors)
  hookErrors?: {              // Hook execution errors
    before?: string[]         // Before hook errors
    after?: string[]          // After hook errors
  }
}
```

### ActionResult (type)
```typescript
interface ActionResult {
  seq: number                  // Execution order
  blockId: string             // NESL block ID
  action: string              // Action type
  params: Record<string, any> // Input parameters
  success: boolean
  error?: string              // Error message if failed
  data?: any                  // Action-specific output
}
```

### ParseError (type)
```typescript
interface ParseError {
  blockId?: string            // If error is block-specific
  error: NeslError            // From parser
}
```

### LoafOptions (type)
```typescript
interface LoafOptions {
  repoPath?: string           // Default: process.cwd()
  gitCommit?: boolean         // v1.2 feature - Default: true
  hooks?: HooksConfig         // Hook configuration (if not provided, loads from loaf.yml)
  enableHooks?: boolean       // Enable hook execution - Default: true
}
```

## Internal Architecture

### Execution Flow
```
execute(llmOutput)
  → loadHooks() if needed
  → runBefore() → HookResult
  → parseNESL(llmOutput) → NeslParseResult
  → for each valid block:
    → convertToActions(block) → LoafAction[]
    → for each action:
      → route to appropriate executor
      → capture result
  → runAfter(context) → HookResult
  → commitChanges(results)
  → return ExecutionResult
```

### Action Routing
- file_* → fs-ops
- dir_* → fs-ops
- exec → exec
- context_* → context
- ls, grep, glob → fs-ops (read operations)

### Error Handling
- Hook errors (before): Fatal, abort with fatalError
- Parser errors: Skip block, record error
- Conversion errors: Skip action, record error
- Execution errors: Continue execution, record error
- Hook errors (after): Record but don't affect success if actions succeeded
- Git errors: Fatal, abort with fatalError
=== END FILE: /Users/stuart/repos/loaf/proj/comp/orch/doc/API.md ===

=== START FILE: /Users/stuart/repos/loaf/proj/comp/orch/doc/ARCH.md ===
# Loaf Architecture


IMPORTANT TOOL TESTING NOTES:

- for test specific loaf tools, each tool must get its own test case file, for easy visibility into which tools have been implemented and tested yet.
- aka `proj/comp/fs-ops/test-data/integration/file_delete.cases.md`

## Core Design Decisions

### Transaction Model
- **No automatic rollback** - All operations commit, including failures
- **Failures are data** - LLM needs failure feedback for next steps
- **Forward-only progress** - Cheaper than regenerating responses
- **Manual rollback only** - Human-initiated via git commands
- **Boundary**: One git commit per `execute()` call
- **API**: Explicit transaction management (details TBD)

### NESL Processing Pipeline
1. NESL parser (external npm) → AST
2. AST → Action objects (nesl-ast-converter)
3. Actions → Execution → Results

### NESL AST Structure
```typescript
interface NeslParseResult {
  blocks: NeslBlock[]
  errors: NeslError[]
}

interface NeslBlock {
  id: string           // 3-char SHA-256
  properties: {
    action: string     // Maps to tool name (e.g., "file_write")
    [key: string]: any // Tool-specific parameters
  }
  startLine: number
  endLine: number
}

interface NeslError {
  code: string         // e.g., "DUPLICATE_KEY"
  line: number
  column: number
  length: number
  blockId: string
  content: string
  context: string
  message: string
}
```

### Error Propagation Strategy
- **Parser errors**: Skip blocks with parser errors, execute valid blocks only
- **Validation errors**: Skip invalid actions, execute valid ones
- **Execution errors**: Continue with remaining actions
- **Result**: Complete execution log with successes and failures

### Action Mapping
- NESL `action` property maps directly to tool names from unified-design.yaml
- Use canonical names: `file_write`, `exec`, etc.

### Context Management
- **V1**: Simple `Set<string>` of file paths
- **Storage**: In-memory only, no persistence across sessions
- **V2 Future**: Sub-file references (lines, functions, sections)

### Hooks Integration
- **Loading**: Lazy-load HooksManager on first execute() if hooks enabled
- **Config Source**: Options > loaf.yml > no hooks
- **Before Hook Failure**: Fatal - prevents NESL execution
- **After Hook Failure**: fatal
- **Context Passing**: Minimal context to after hooks (success, counts)
- **Variable Interpolation**: Handled by hooks component, not orch

### Execution Model
- **Synchronous**: All operations block until complete
- **CWD Management**: Session-based working directory
  - Default: Repository root
  - Each exec can override with `cwd` parameter
  - CWD persists within session, not across transactions
- **Results Format**: Flat array with sequence numbers
```typescript
interface ActionResult {
  seq: number          // Execution order
  blockId: string      // NESL block ID
  action: string       // Action type
  params: any          // Input parameters
  success: boolean
  error?: string       // Error message if failed
  data?: any           // Action-specific output (stdout, content, etc.)
}
```

### Security Model (V1)
- **None**: Full filesystem access
- **No validation**: Any path allowed
- **No sandboxing**: Direct execution
- **V2 Future**: Path allowlisting per unified-design.yaml. FOR THIS REASON all fs stuff should immediately be implemented using our fs wrapper functions so this whitelisting/blacklisting is easy to implment in the future.

## Component Structure
```
loaf/
├── proj/
│   ├── comp/
│   │   ├── nesl-ast-converter/  # AST → Actions
│   │   ├── fs-ops/              # File/directory operations
│   │   ├── exec/                # Command execution
│   │   ├── git-tx/              # Git transaction management
│   │   └── context/             # Working set management
│   └── doc/
│       ├── API.md               # Main orchestrator API
│       ├── ARCH.md              # This document
│       └── ABSTRACT.md          # Project overview
```

## Implementation Priorities
1. `nesl-ast-converter` - Cannot test without this
2. `fs-ops` - Core functionality
3. `exec` - Command execution
4. `git-tx` - Transaction wrapper
5. `context` - Working set (may be simple enough to inline)

## Open Questions

### Critical
1. **NESL parser package**: `nesl-js` from `github:nesl-lang/nesl-js`
   - Import: `const { parseNESL } = require('nesl-js')`
2. **Transaction API**: Single `execute()` method processes NESL block array

### Design
1. **Parser error handling**: Execute blocks with parser errors or skip?
2. **Git conflict handling**: How to handle conflicts during manual rollback?
3. **Concurrent access**: Multiple loaf instances on same repo?
4. **Partial failure behavior**: Continue executing after first failure or abort?

### Future
1. **Context references**: Syntax for line ranges and functions
2. **Execution isolation**: Container/VM strategy for V2
3. **Streaming results**: Return results as actions complete or batch at end?

## Design Rationale

### Why No Automatic Rollback
Traditional transaction systems rollback on failure to maintain consistency. Loaf explicitly rejects this because:
1. **LLM responses are expensive** - Regenerating costs time and money
2. **Partial success is informative** - LLM learns from failures
3. **Git preserves history** - Can always manually revert
4. **Forward progress over perfection** - Incremental improvement model

### Why Synchronous Execution
1. **Deterministic results** - LLM needs to know exact outcomes
2. **Sequential dependencies** - Later actions may depend on earlier ones
3. **Simpler implementation** - No async state management
4. **Git compatibility** - Git operations are inherently synchronous

### Why In-Memory Context
1. **Session isolation** - Each LLM conversation is independent
2. **No persistence complexity** - No file format versioning
3. **Git is the source of truth** - Files on disk matter, not context
4. **Quick reset** - New session = clean slate
=== END FILE: /Users/stuart/repos/loaf/proj/comp/orch/doc/ARCH.md ===

=== START FILE: /Users/stuart/repos/loaf/proj/comp/orch/src/createStarterConfig.ts ===
import { writeFile } from 'fs/promises';
import { join } from 'path';

const STARTER_LOAF_YML = `# Loaf configuration
version: 1

# File system guard configuration
fs-guard:
  # Allowed paths (supports glob patterns)
  # Relative paths are resolved from this config file's location
  allowed:
    - "./**"           # All files in project
    - "/tmp/**"        # Temporary files
  
  # Denied paths (more specific rules override less specific)
  denied:
    - "**/.git/**"     # Git internals
    - "**/.ssh/**"     # SSH keys
    - "**/node_modules/**"  # Dependencies
  
  # Whether to follow symlinks (default: false)
  followSymlinks: false

# Git hooks configuration
hooks:
  before: []
  after: []
  
  # Example hooks (uncomment to use):
  # before:
  #   - run: git stash --include-untracked
  #     continueOnError: false
  
  # after:
  #   - run: git add -A
  #   - run: git commit -m "\${COMMIT_MSG}"
  #     continueOnError: false
  #   - run: git push
  #     continueOnError: true
  #     timeout: 10000  # 10s for slow networks

# Variables available in commands
vars:
  COMMIT_MSG: "AI-assisted changes"
  # Add more variables as needed
`;

/**
 * Creates a starter loaf.yml file if it doesn't exist
 * @returns true if file was created, false if already exists
 */
export async function createStarterConfig(repoPath: string): Promise<boolean> {
  const configPath = join(repoPath, 'loaf.yml');
  
  try {
    await writeFile(configPath, STARTER_LOAF_YML, { flag: 'wx' });
    return true;
  } catch (error: any) {
    if (error.code === 'EEXIST') {
      return false;
    }
    throw error;
  }
}
=== END FILE: /Users/stuart/repos/loaf/proj/comp/orch/src/createStarterConfig.ts ===

=== START FILE: /Users/stuart/repos/loaf/proj/comp/hooks/src/parseYamlConfig.ts ===
import { load } from 'js-yaml';
import type { HooksConfig } from './types.js';

/**
 * Parses YAML content into HooksConfig object
 * @throws Error if YAML is invalid
 */
export function parseYamlConfig(content: string): HooksConfig {
  try {
    // Empty string returns null from js-yaml
    if (content.trim() === '') {
      return null as any;
    }

    const parsed = load(content);
    
    // js-yaml returns undefined for empty documents sometimes
    if (parsed === undefined) {
      return null as any;
    }

    return parsed as HooksConfig;
  } catch (error: any) {
    throw new Error(`Invalid YAML: ${error.message}`);
  }
}
=== END FILE: /Users/stuart/repos/loaf/proj/comp/hooks/src/parseYamlConfig.ts ===

=== START FILE: /Users/stuart/repos/loaf/proj/comp/hooks/src/validateConfig.ts ===
import type { HooksConfig, ValidationResult } from './types.js';

/**
 * Validates a parsed config object has correct structure
 * Checks hooks is object, before/after are arrays, commands are objects
 * vars is object with string values
 */
export function validateConfig(config: any): ValidationResult {
  // Empty config is valid
  if (!config || typeof config !== 'object') {
    return {
      valid: false,
      error: 'Config must be an object'
    };
  }

  // Check hooks if present
  if ('hooks' in config && config.hooks !== undefined) {
    if (typeof config.hooks !== 'object' || config.hooks === null) {
      return {
        valid: false,
        error: 'hooks must be an object'
      };
    }

    // Check before hooks
    if ('before' in config.hooks && config.hooks.before !== undefined) {
      if (!Array.isArray(config.hooks.before)) {
        return {
          valid: false,
          error: 'hooks.before must be an array'
        };
      }

      // Check each before command
      for (const cmd of config.hooks.before) {
        if (typeof cmd !== 'object' || cmd === null) {
          return {
            valid: false,
            error: 'hook commands must be objects'
          };
        }
      }
    }

    // Check after hooks
    if ('after' in config.hooks && config.hooks.after !== undefined) {
      if (!Array.isArray(config.hooks.after)) {
        return {
          valid: false,
          error: 'hooks.after must be an array'
        };
      }

      // Check each after command
      for (const cmd of config.hooks.after) {
        if (typeof cmd !== 'object' || cmd === null) {
          return {
            valid: false,
            error: 'hook commands must be objects'
          };
        }
      }
    }
  }

  // Check vars if present
  if ('vars' in config && config.vars !== undefined) {
    if (typeof config.vars !== 'object' || config.vars === null || Array.isArray(config.vars)) {
      return {
        valid: false,
        error: 'vars must be an object'
      };
    }

    // Check all var values are strings
    for (const value of Object.values(config.vars)) {
      if (typeof value !== 'string') {
        return {
          valid: false,
          error: 'var values must be strings'
        };
      }
    }
  }

  return { valid: true };
}
=== END FILE: /Users/stuart/repos/loaf/proj/comp/hooks/src/validateConfig.ts ===

